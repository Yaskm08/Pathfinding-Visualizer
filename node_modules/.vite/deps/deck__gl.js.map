{
  "version": 3,
  "sources": ["../../@deck.gl/aggregation-layers/src/utils/aggregation-operation-utils.js", "../../@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js", "../../@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js", "../../@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js", "../../@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js", "../../@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js", "../../@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/transform-mean-vs.glsl.js", "../../@deck.gl/aggregation-layers/src/utils/resource-utils.js", "../../@deck.gl/aggregation-layers/src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js", "../../@deck.gl/aggregation-layers/src/utils/color-utils.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer-vertex.glsl.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer-fragment.glsl.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-cell-layer.ts", "../../@deck.gl/aggregation-layers/src/utils/prop-utils.js", "../../@deck.gl/aggregation-layers/src/aggregation-layer.ts", "../../@deck.gl/aggregation-layers/src/utils/scale-utils.js", "../../@deck.gl/aggregation-layers/src/utils/bin-sorter.ts", "../../@deck.gl/aggregation-layers/src/utils/grid-aggregation-utils.js", "../../@deck.gl/aggregation-layers/src/cpu-grid-layer/grid-aggregator.js", "../../@deck.gl/aggregation-layers/src/grid-aggregation-layer.ts", "../../@deck.gl/aggregation-layers/src/screen-grid-layer/screen-grid-layer.ts", "../../@deck.gl/aggregation-layers/src/utils/cpu-aggregator.js", "../../@deck.gl/aggregation-layers/src/cpu-grid-layer/cpu-grid-layer.ts", "../../d3-hexbin/src/hexbin.js", "../../@deck.gl/aggregation-layers/src/hexagon-layer/hexagon-aggregator.js", "../../@deck.gl/aggregation-layers/src/hexagon-layer/hexagon-layer.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/marching-squares-codes.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/marching-squares.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/contour-utils.ts", "../../@deck.gl/aggregation-layers/src/contour-layer/contour-layer.ts", "../../@deck.gl/aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.ts", "../../@deck.gl/aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.ts", "../../@deck.gl/aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer.ts", "../../@deck.gl/aggregation-layers/src/gpu-grid-layer/gpu-grid-layer.ts", "../../@deck.gl/aggregation-layers/src/grid-layer/grid-layer.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/heatmap-layer-utils.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/triangle-layer-vertex.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/triangle-layer-fragment.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/triangle-layer.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/weights-vs.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/weights-fs.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/max-vs.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/max-fs.glsl.ts", "../../@deck.gl/aggregation-layers/src/heatmap-layer/heatmap-layer.ts"],
  "sourcesContent": ["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport const AGGREGATION_OPERATION = {\n  SUM: 1,\n  MEAN: 2,\n  MIN: 3,\n  MAX: 4\n};\n\nfunction sumReducer(accu, cur) {\n  return accu + cur;\n}\n\nfunction maxReducer(accu, cur) {\n  return cur > accu ? cur : accu;\n}\n\nfunction minReducer(accu, cur) {\n  return cur < accu ? cur : accu;\n}\n\nexport function getMean(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n\n  return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;\n}\n\nexport function getSum(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? pts.length * accessor : null;\n  }\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n\n  return filtered.length ? filtered.reduce(sumReducer, 0) : null;\n}\n\nexport function getMax(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n\n  return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;\n}\n\nexport function getMin(pts, accessor) {\n  if (Number.isFinite(accessor)) {\n    return pts.length ? accessor : null;\n  }\n  const filtered = pts.map(accessor).filter(Number.isFinite);\n\n  return filtered.length ? filtered.reduce(minReducer, Infinity) : null;\n}\n\n// Function to convert from aggregation/accessor props (like colorAggregation and getColorWeight) to getValue prop (like getColorValue)\nexport function getValueFunc(aggregation, accessor, context) {\n  const op = AGGREGATION_OPERATION[aggregation] || AGGREGATION_OPERATION.SUM;\n  accessor = wrapAccessor(accessor, context);\n  switch (op) {\n    case AGGREGATION_OPERATION.MIN:\n      return pts => getMin(pts, accessor);\n    case AGGREGATION_OPERATION.SUM:\n      return pts => getSum(pts, accessor);\n    case AGGREGATION_OPERATION.MEAN:\n      return pts => getMean(pts, accessor);\n    case AGGREGATION_OPERATION.MAX:\n      return pts => getMax(pts, accessor);\n    default:\n      return null;\n  }\n}\n\nfunction wrapAccessor(accessor, context = {}) {\n  if (Number.isFinite(accessor)) {\n    return accessor;\n  }\n  return pt => {\n    context.index = pt.index;\n    return accessor(pt.source, context);\n  };\n}\n\nexport function wrapGetValueFunc(getValue, context = {}) {\n  return pts => {\n    context.indices = pts.map(pt => pt.index);\n    return getValue(\n      pts.map(pt => pt.source),\n      context\n    );\n  };\n}\n", "import GL from '@luma.gl/constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nexport const DEFAULT_RUN_PARAMS = {\n  projectPoints: false,\n  viewport: null,\n  createBufferObjects: true,\n  moduleSettings: {}\n};\n\nexport const MAX_32_BIT_FLOAT = 3.402823466e38;\nexport const MIN_BLEND_EQUATION = [GL.MIN, GL.FUNC_ADD];\nexport const MAX_BLEND_EQUATION = [GL.MAX, GL.FUNC_ADD];\nexport const MAX_MIN_BLEND_EQUATION = [GL.MAX, GL.MIN];\nexport const EQUATION_MAP = {\n  [AGGREGATION_OPERATION.SUM]: GL.FUNC_ADD,\n  [AGGREGATION_OPERATION.MEAN]: GL.FUNC_ADD,\n  [AGGREGATION_OPERATION.MIN]: MIN_BLEND_EQUATION,\n  [AGGREGATION_OPERATION.MAX]: MAX_BLEND_EQUATION\n};\n\nexport const ELEMENTCOUNT = 4;\nexport const DEFAULT_WEIGHT_PARAMS = {\n  size: 1,\n  operation: AGGREGATION_OPERATION.SUM,\n  needMin: false,\n  needMax: false,\n  combineMaxMin: false\n};\n\nexport const PIXEL_SIZE = 4; // RGBA32F\nexport const WEIGHT_SIZE = 3;\n\nexport const MAX_MIN_TEXTURE_OPTS = {\n  format: GL.RGBA32F,\n  type: GL.FLOAT,\n  border: 0,\n  mipmaps: false,\n  parameters: {\n    [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n    [GL.TEXTURE_MIN_FILTER]: GL.NEAREST\n  },\n  dataFormat: GL.RGBA,\n  width: 1,\n  height: 1\n};\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME gpu-aggregation-to-grid-vs\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute vec3 weights;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform bool projectPoints;\nuniform vec2 translation;\nuniform vec3 scaling;\n\nvarying vec3 vWeights;\n\nvec2 project_to_pixel(vec4 pos) {\n  vec4 result;\n  pos.xy = pos.xy/pos.w;\n  result = pos + vec4(translation, 0., 0.);\n  result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;\n  return result.xy;\n}\n\nvoid main(void) {\n\n  vWeights = weights;\n\n  vec4 windowPos = vec4(positions, 1.);\n  if (projectPoints) {\n    windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));\n  }\n\n  vec2 pos = project_to_pixel(windowPos);\n\n  vec2 pixelXY64[2];\n  pixelXY64[0] = vec2(pos.x, 0.);\n  pixelXY64[1] = vec2(pos.y, 0.);\n\n  // Transform (0,0):windowSize -> (0, 0): gridSize\n  vec2 gridXY64[2];\n  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\n  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\n  float x = floor(gridXY64[0].x);\n  float y = floor(gridXY64[1].x);\n  pos = vec2(x, y);\n\n  // Transform (0,0):gridSize -> (-1, -1):(1,1)\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n\n  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\n  gl_PointSize = 1.0;\n}\n`;\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME gpu-aggregation-to-grid-fs\n\nprecision highp float;\n\nvarying vec3 vWeights;\n\nvoid main(void) {\n  gl_FragColor = vec4(vWeights, 1.0);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-all-vs-64\n\nin vec2 position;\nuniform ivec2 gridSize;\nout vec2 vTextureCoord;\n\nvoid main(void) {\n  // Map each position to single pixel\n  vec2 pos = vec2(-1.0, -1.0);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / vec2(gridSize);\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n\n  int yIndex = gl_InstanceID / gridSize[0];\n  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);\n\n  vec2 yIndexFP64 = vec2(float(yIndex), 0.);\n  vec2 xIndexFP64 = vec2(float(xIndex), 0.);\n  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);\n  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);\n\n  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);\n  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);\n\n  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);\n  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\n  gl_PointSize = 1.0;\n}\n`;\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-all-fs\n\nprecision highp float;\n\nin vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform bool combineMaxMin;\nout vec4 fragColor;\nvoid main(void) {\n  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n  if (textureColor.a == 0.) {\n    discard;\n  }\n  fragColor.rgb = textureColor.rgb;\n  // if combineMinMax is true, use Alpha channel for first weights min value.\n  fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;\n}\n`;\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME gpu-aggregation-transform-mean-vs\nattribute vec4 aggregationValues;\nvarying vec4 meanValues;\n\nvoid main()\n{\n  // TODO: Use 64-bit division ?? not needed given this is aggregation ??\n  bool isCellValid = bool(aggregationValues.w > 0.);\n  // aggregationValues:  XYZ contain aggregated values, W contains count\n  meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);\n  meanValues.w = aggregationValues.w;\n\n  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\n  gl_PointSize = 1.0;\n}\n`;\n", "import GL from '@luma.gl/constants';\nimport {Framebuffer, Texture2D, isWebGL2} from '@luma.gl/core';\n\nconst DEFAULT_PARAMETERS = {\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST\n};\n\nexport function getFloatTexture(gl, opts = {}) {\n  const {\n    width = 1,\n    height = 1,\n    data = null,\n    unpackFlipY = true,\n    parameters = DEFAULT_PARAMETERS\n  } = opts;\n  const texture = new Texture2D(gl, {\n    data,\n    format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n    type: GL.FLOAT,\n    border: 0,\n    mipmaps: false,\n    parameters,\n    dataFormat: GL.RGBA,\n    width,\n    height,\n    unpackFlipY\n  });\n  return texture;\n}\n\nexport function getFramebuffer(gl, opts) {\n  const {id, width = 1, height = 1, texture} = opts;\n  const fb = new Framebuffer(gl, {\n    id,\n    width,\n    height,\n    attachments: {\n      [GL.COLOR_ATTACHMENT0]: texture\n    }\n  });\n\n  return fb;\n}\n\nexport function getFloatArray(array, size, fillValue = 0) {\n  if (!array || array.length < size) {\n    return new Float32Array(size).fill(fillValue);\n  }\n  return array;\n}\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel?.delete();\n    allAggregationModel?.delete();\n    meanTransform?.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {...DEFAULT_RUN_PARAMS, ...opts};\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {...parameters, blendEquation: MAX_MIN_BLEND_EQUATION},\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MIN_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MAX_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: {...parameters, blendEquation: equations[id]},\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    this.gridAggregationModel?.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {...DEFAULT_WEIGHT_PARAMS, ...weights[id]};\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport const defaultColorRange: [number, number, number][] = [\n  [255, 255, 178],\n  [254, 217, 118],\n  [254, 178, 76],\n  [253, 141, 60],\n  [240, 59, 32],\n  [189, 0, 38]\n];\n\n// Converts a colorRange array to a flat array with 4 components per color\nexport function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {\n  let flatArray;\n\n  if (Number.isFinite(colorRange[0])) {\n    // its already a flat array.\n    flatArray = new ArrayType(colorRange);\n  } else {\n    // flatten it\n    flatArray = new ArrayType(colorRange.length * 4);\n    let index = 0;\n\n    for (let i = 0; i < colorRange.length; i++) {\n      const color = colorRange[i];\n      flatArray[index++] = color[0];\n      flatArray[index++] = color[1];\n      flatArray[index++] = color[2];\n      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\n    }\n  }\n\n  if (normalize) {\n    for (let i = 0; i < flatArray.length; i++) {\n      flatArray[i] /= 255;\n    }\n  }\n  return flatArray;\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\n\nattribute vec3 positions;\nattribute vec3 instancePositions;\nattribute vec4 instanceCounts;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\nuniform sampler2D maxTexture;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= domain.x && value <= domain.y) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  outColor = outColor / 255.;\n  return outColor;\n}\n\nvoid main(void) {\n  vSampleCount = instanceCounts.a;\n\n  float weight = instanceCounts.r;\n  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;\n\n  float step = weight / maxWeight;\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\n\n  vec2 domain = colorDomain;\n  float domainMaxValid = float(colorDomain.y != 0.);\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\n\n  float rangeMinMax = float(shouldUseMinMax);\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\n  vColor = vec4(color.rgb, color.a * opacity);\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* fragment shader for the grid-layer */\nexport default `\\\n#define SHADER_NAME screen-grid-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvoid main(void) {\n  if (vSampleCount <= 0.0) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, FEATURES, hasFeatures, Texture2D, DefaultProps} from '@luma.gl/core';\nimport {Layer, LayerProps, log, picking, UpdateParameters} from '@deck.gl/core';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nimport type {_ScreenGridLayerProps} from './screen-grid-layer';\n\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = ['minColor', 'maxColor', 'colorRange', 'colorDomain'];\n\nconst defaultProps: DefaultProps<ScreenGridCellLayerProps> = {\n  cellSizePixels: {value: 100, min: 1},\n  cellMarginPixels: {value: 2, min: 0, max: 5},\n\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\n/** All properties supported by ScreenGridCellLayer. */\nexport type ScreenGridCellLayerProps<DataT = any> = _ScreenGridCellLayerProps<DataT> & LayerProps;\n\n/** Proprties added by ScreenGridCellLayer. */\nexport type _ScreenGridCellLayerProps<DataT> = _ScreenGridLayerProps<DataT> & {\n  maxTexture: Texture2D;\n};\n\nexport default class ScreenGridCellLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScreenGridCellLayerProps<DataT>>\n> {\n  static layerName = 'ScreenGridCellLayer';\n  static defaultProps = defaultProps;\n\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  state!: Layer['state'] & {\n    model: Model;\n  };\n  getShaders() {\n    return {vs, fs, modules: [picking]};\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.addInstanced({\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCounts: {size: 4, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // 'instanceCounts' buffer contetns change on viewport change.\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {oldProps, props, changeFlags} = params;\n\n    const attributeManager = this.getAttributeManager()!;\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({uniforms}) {\n    const {parameters, maxTexture} = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n\n    // If colorDomain not specified we use default domain [1, maxCount]\n    // maxCount value will be sampled form maxTexture in vertex shader.\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {model} = this.state;\n    model\n      .setUniforms(uniforms)\n      .setUniforms({\n        minColor,\n        maxColor,\n        maxTexture,\n        colorDomain\n      })\n      .draw({\n        parameters: {\n          depthTest: false,\n          depthMask: false,\n          ...parameters\n        }\n      });\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  // Private Methods\n\n  _getModel(gl: WebGLRenderingContext): Model {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax(): boolean {\n    const {minColor, maxColor, colorDomain, colorRange} = this.props;\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n    if (colorDomain || colorRange) {\n      return false;\n    }\n    // None specified, use default minColor and maxColor\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags): void {\n    const {model} = this.state;\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({colorRange: colorRangeToFlatArray(props.colorRange)});\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels, cellMarginPixels} = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n\n      const cellScale = new Float32Array([\n        ((cellSizePixels - margin) / width) * 2,\n        (-(cellSizePixels - margin) / height) * 2,\n        1\n      ]);\n      model.setUniforms({cellScale});\n    }\n  }\n}\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport function filterProps(props, filterKeys) {\n  const filteredProps = {};\n  for (const key in props) {\n    if (!filterKeys.includes(key)) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  CompositeLayer,\n  AttributeManager,\n  LayerDataSource,\n  _compareProps as compareProps,\n  UpdateParameters,\n  CompositeLayerProps\n} from '@deck.gl/core';\nimport {cssToDeviceRatio} from '@luma.gl/core';\nimport {filterProps} from './utils/prop-utils';\n\nexport type AggregationLayerProps<DataT> = CompositeLayerProps & {\n  data: LayerDataSource<DataT>;\n};\n\nexport default abstract class AggregationLayer<\n  DataT,\n  ExtraPropsT extends {} = {}\n> extends CompositeLayer<Required<AggregationLayer<DataT>> & ExtraPropsT> {\n  static layerName = 'AggregationLayer';\n\n  state!: CompositeLayer['state'] & {\n    ignoreProps?: Record<string, any>;\n    dimensions?: any;\n  };\n\n  initializeAggregationLayer(dimensions: any) {\n    super.initializeState(this.context);\n\n    this.setState({\n      // Layer props , when changed doesn't require updating aggregation\n      ignoreProps: filterProps((this.constructor as any)._propTypes, dimensions.data.props),\n      dimensions\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n    const {changeFlags} = opts;\n    if (changeFlags.extensionsChanged) {\n      const shaders = this.getShaders({});\n      if (shaders && shaders.defines) {\n        shaders.defines.NON_INSTANCED_MODEL = 1;\n      }\n      this.updateShaders(shaders);\n    }\n\n    // Explictly call to update attributes as 'CompositeLayer' doesn't call this\n    this._updateAttributes();\n  }\n\n  updateAttributes(changedAttributes) {\n    // Super classes, can refer to state.changedAttributes to determine what\n    // attributes changed\n    this.setState({changedAttributes});\n  }\n\n  getAttributes() {\n    return this.getAttributeManager()!.getShaderAttributes();\n  }\n\n  getModuleSettings() {\n    // For regular layer draw this happens during draw cycle (_drawLayersInViewport) not during update cycle\n    // For aggregation layers this is called during updateState to update aggregation data\n    // NOTE: it is similar to LayerPass._getModuleParameters() but doesn't inlcude `effects` it is not needed for aggregation\n    const {viewport, mousePosition, gl} = this.context;\n    const moduleSettings = Object.assign(Object.create(this.props), {\n      viewport,\n      mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(gl)\n    });\n    return moduleSettings;\n  }\n\n  updateShaders(shaders) {\n    // Default implemention is empty, subclasses can update their Model objects if needed\n  }\n\n  /**\n   * Checks if aggregation is dirty\n   * @param {Object} updateOpts - object {props, oldProps, changeFlags}\n   * @param {Object} params - object {dimension, compareAll}\n   * @param {Object} params.dimension - {props, accessors} array of props and/or accessors\n   * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision\n   * @returns {Boolean} - returns true if dimensions' prop or accessor is changed\n   **/\n  isAggregationDirty(\n    updateOpts,\n    params: {compareAll?: boolean; dimension?: any} = {}\n  ): string | boolean {\n    const {props, oldProps, changeFlags} = updateOpts;\n    const {compareAll = false, dimension} = params;\n    const {ignoreProps} = this.state;\n    const {props: dataProps, accessors = []} = dimension;\n    const {updateTriggersChanged} = changeFlags;\n    if (changeFlags.dataChanged) {\n      return true;\n    }\n    if (updateTriggersChanged) {\n      if (updateTriggersChanged.all) {\n        return true;\n      }\n      for (const accessor of accessors) {\n        if (updateTriggersChanged[accessor]) {\n          return true;\n        }\n      }\n    }\n    if (compareAll) {\n      if (changeFlags.extensionsChanged) {\n        return true;\n      }\n      // Compare non layer props too (like extension props)\n      // ignoreprops refers to all Layer props other than aggregation props that need to be comapred\n      return compareProps({\n        oldProps,\n        newProps: props,\n        ignoreProps,\n        propTypes: (this.constructor as any)._propTypes\n      });\n    }\n    // Compare props of the dimension\n    for (const name of dataProps) {\n      if (props[name] !== oldProps[name]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks if an attribute is changed\n   * @param {String} name - name of the attribute\n   * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,\n   *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise\n   **/\n  isAttributeChanged(name?: string) {\n    const {changedAttributes} = this.state;\n    if (!name) {\n      // if name not specified return true if any attribute is changed\n      return !isObjectEmpty(changedAttributes);\n    }\n    return changedAttributes && changedAttributes[name] !== undefined;\n  }\n\n  // Private\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n}\n\n// Helper methods\n\n// Returns true if given object is empty, false otherwise.\nfunction isObjectEmpty(obj) {\n  let isEmpty = true;\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const key in obj) {\n    isEmpty = false;\n    break;\n  }\n  return isEmpty;\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\n\n// a scale function wrapper just like d3-scales\nexport function getScale(domain, range, scaleFunction) {\n  const scale = scaleFunction;\n  scale.domain = () => domain;\n  scale.range = () => range;\n\n  return scale;\n}\n\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\n// return a quantize scale function\nexport function getQuantizeScale(domain, range) {\n  const scaleFunction = value => quantizeScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\n// return a linear scale function\nexport function getLinearScale(domain, range) {\n  const scaleFunction = value => linearScale(domain, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\nexport function getQuantileScale(domain, range) {\n  // calculate threshold\n  const sortedDomain = domain.sort(ascending);\n  let i = 0;\n  const n = Math.max(1, range.length);\n  const thresholds = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n\n  const scaleFunction = value => thresholdsScale(thresholds, range, value);\n  scaleFunction.thresholds = () => thresholds;\n\n  return getScale(domain, range, scaleFunction);\n}\n\nfunction ascending(a, b) {\n  return a - b;\n}\n\nfunction threshold(domain, fraction) {\n  const domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a, x) {\n  let lo = 0;\n  let hi = a.length;\n  while (lo < hi) {\n    const mid = (lo + hi) >>> 1;\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n\n// return a quantize scale function\nfunction thresholdsScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\n\n// ordinal Scale\nfunction ordinalScale(domain, domainMap, range, value) {\n  const key = `${value}`;\n  let d = domainMap.get(key);\n  if (d === undefined) {\n    // update the domain\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n  return range[(d - 1) % range.length];\n}\n\nexport function getOrdinalScale(domain, range) {\n  const domainMap = new Map();\n  const uniqueDomain = [];\n  for (const d of domain) {\n    const key = `${d}`;\n    if (!domainMap.has(key)) {\n      domainMap.set(key, uniqueDomain.push(d));\n    }\n  }\n\n  const scaleFunction = value => ordinalScale(uniqueDomain, domainMap, range, value);\n\n  return getScale(domain, range, scaleFunction);\n}\n\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\nexport function quantizeScale(domain, range, value) {\n  const domainRange = domain[1] - domain[0];\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n  const step = domainRange / range.length;\n  const idx = Math.floor((value - domain[0]) / step);\n  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n\n  return range[clampIdx];\n}\n\n// Linear scale maps continuous domain to continuous range\nexport function linearScale(domain, range, value) {\n  return ((value - domain[0]) / (domain[1] - domain[0])) * (range[1] - range[0]) + range[0];\n}\n\n// get scale domains\nfunction notNullOrUndefined(d) {\n  return d !== undefined && d !== null;\n}\n\nexport function unique(values) {\n  const results = [];\n  values.forEach(v => {\n    if (!results.includes(v) && notNullOrUndefined(v)) {\n      results.push(v);\n    }\n  });\n\n  return results;\n}\n\nfunction getTruthyValues(data, valueAccessor) {\n  const values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n  return values.filter(notNullOrUndefined);\n}\n\nexport function getLinearDomain(data, valueAccessor) {\n  const sorted = getTruthyValues(data, valueAccessor).sort();\n  return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\n\nexport function getQuantileDomain(data, valueAccessor) {\n  return getTruthyValues(data, valueAccessor);\n}\n\nexport function getOrdinalDomain(data, valueAccessor) {\n  return unique(getTruthyValues(data, valueAccessor));\n}\n\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n  switch (scaleType) {\n    case 'quantize':\n    case 'linear':\n      return getLinearDomain(data, valueAccessor);\n\n    case 'quantile':\n      return getQuantileDomain(data, valueAccessor);\n\n    case 'ordinal':\n      return getOrdinalDomain(data, valueAccessor);\n\n    default:\n      return getLinearDomain(data, valueAccessor);\n  }\n}\n\nexport function clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\nexport function getScaleFunctionByScaleType(scaleType) {\n  switch (scaleType) {\n    case 'quantize':\n      return getQuantizeScale;\n    case 'linear':\n      return getLinearScale;\n    case 'quantile':\n      return getQuantileScale;\n    case 'ordinal':\n      return getOrdinalScale;\n\n    default:\n      return getQuantizeScale;\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// getValue takes an array of points returns a value to sort the bins on.\n// by default it returns the number of points\n// this is where to pass in a function to color the bins by\n// avg/mean/max of specific value of the point\nconst defaultGetValue = points => points.length;\n\nimport {clamp, getQuantileDomain, getOrdinalDomain} from './scale-utils';\n\nconst MAX_32_BIT_FLOAT = 3.402823466e38;\n\n// access array of points in each bin\nconst defaultGetPoints = bin => bin.points;\n// access index of each bin\nconst defaultGetIndex = bin => bin.index;\n\n// d3-scending\nconst ascending = (a, b) => (a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN);\n\nconst defaultProps = {\n  getValue: defaultGetValue,\n  getPoints: defaultGetPoints,\n  getIndex: defaultGetIndex,\n  filterData: null\n};\n\nexport type AggregatedBin = {\n  i: number;\n  value: any;\n  counts: number;\n};\n\nexport default class BinSorter {\n  maxCount!: number;\n  maxValue!: number;\n  minValue!: number;\n  totalCount!: number;\n\n  aggregatedBins: AggregatedBin[];\n  sortedBins!: AggregatedBin[];\n  binMap: Record<number, AggregatedBin>;\n\n  constructor(bins = [], props: Partial<typeof defaultProps> = defaultProps) {\n    this.aggregatedBins = this.getAggregatedBins(bins, props);\n    this._updateMinMaxValues();\n    this.binMap = this.getBinMap();\n  }\n\n  /**\n   * Get an array of object with aggregated values and index of bins\n   * Array object will be sorted by value optionally.\n   * @param {Array} bins\n   * @param {Function} getValue\n   * @return {Array} array of values and index lookup\n   */\n  getAggregatedBins(bins, props): AggregatedBin[] {\n    const {\n      getValue = defaultGetValue,\n      getPoints = defaultGetPoints,\n      getIndex = defaultGetIndex,\n      filterData\n    } = props;\n\n    const hasFilter = typeof filterData === 'function';\n    const binCount = bins.length;\n    const aggregatedBins: AggregatedBin[] = [];\n    let index = 0;\n\n    for (let binIndex = 0; binIndex < binCount; binIndex++) {\n      const bin = bins[binIndex];\n      const points = getPoints(bin);\n      const i = getIndex(bin);\n\n      const filteredPoints = hasFilter ? points.filter(filterData) : points;\n\n      bin.filteredPoints = hasFilter ? filteredPoints : null;\n\n      const value = filteredPoints.length ? getValue(filteredPoints) : null;\n\n      if (value !== null && value !== undefined) {\n        // filter bins if value is null or undefined\n        aggregatedBins[index] = {\n          i: Number.isFinite(i) ? i : binIndex,\n          value,\n          counts: filteredPoints.length\n        };\n        index++;\n      }\n    }\n    return aggregatedBins;\n  }\n\n  _percentileToIndex(percentileRange): [number, number] {\n    const len = this.sortedBins.length;\n    if (len < 2) {\n      return [0, 0];\n    }\n\n    const [lower, upper] = percentileRange.map(n => clamp(n, 0, 100));\n\n    const lowerIdx = Math.ceil((lower / 100) * (len - 1));\n    const upperIdx = Math.floor((upper / 100) * (len - 1));\n\n    return [lowerIdx, upperIdx];\n  }\n\n  /**\n   * Get a mapping from cell/hexagon index to sorted bin\n   * This is used to retrieve bin value for color calculation\n   * @return {Object} bin index to aggregatedBins\n   */\n  getBinMap(): Record<number, AggregatedBin> {\n    const binMap = {};\n    for (const bin of this.aggregatedBins) {\n      binMap[bin.i] = bin;\n    }\n    return binMap;\n  }\n\n  // Private\n\n  /**\n   * Get ths max count of all bins\n   */\n  _updateMinMaxValues(): void {\n    let maxCount = 0;\n    let maxValue = 0;\n    let minValue = MAX_32_BIT_FLOAT;\n    let totalCount = 0;\n    for (const x of this.aggregatedBins) {\n      maxCount = maxCount > x.counts ? maxCount : x.counts;\n      maxValue = maxValue > x.value ? maxValue : x.value;\n      minValue = minValue < x.value ? minValue : x.value;\n      totalCount += x.counts;\n    }\n    this.maxCount = maxCount;\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n    this.totalCount = totalCount;\n  }\n\n  /**\n   * Get range of values of all bins\n   * @param {Number[]} range\n   * @param {Number} range[0] - lower bound\n   * @param {Number} range[1] - upper bound\n   * @return {Array} array of new value range\n   */\n  getValueRange(percentileRange: [number, number]): [number, number] {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n    if (!this.sortedBins.length) {\n      // @ts-expect-error\n      return [];\n    }\n    let lowerIdx = 0;\n    let upperIdx = this.sortedBins.length - 1;\n\n    if (Array.isArray(percentileRange)) {\n      const idxRange = this._percentileToIndex(percentileRange);\n      lowerIdx = idxRange[0];\n      upperIdx = idxRange[1];\n    }\n\n    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n  }\n\n  getValueDomainByScale(scale: string, [lower = 0, upper = 100] = []) {\n    if (!this.sortedBins) {\n      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n    }\n    if (!this.sortedBins.length) {\n      return [];\n    }\n    const indexEdge = this._percentileToIndex([lower, upper]);\n\n    return this._getScaleDomain(scale, indexEdge);\n  }\n\n  _getScaleDomain(scaleType: string, [lowerIdx, upperIdx]: [number, number]): [number, number] {\n    const bins = this.sortedBins;\n\n    switch (scaleType) {\n      case 'quantize':\n      case 'linear':\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n\n      case 'quantile':\n        return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), d => d.value);\n\n      case 'ordinal':\n        return getOrdinalDomain(bins, d => d.value) as [number, number];\n\n      default:\n        return [bins[lowerIdx].value, bins[upperIdx].value];\n    }\n  }\n}\n", "import {log, COORDINATE_SYSTEM} from '@deck.gl/core';\nconst R_EARTH = 6378000;\n\nfunction toFinite(n) {\n  return Number.isFinite(n) ? n : 0;\n}\n\n// Parse input data to build positions, wights and bounding box.\n/* eslint-disable max-statements */\nexport function getBoundingBox(attributes, vertexCount) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = attributes.positions.value;\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 3];\n    y = positions[i * 3 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  const boundingBox = {\n    xMin: toFinite(xMin),\n    xMax: toFinite(xMax),\n    yMin: toFinite(yMin),\n    yMax: toFinite(yMax)\n  };\n\n  return boundingBox;\n}\n/* eslint-enable max-statements */\n\n// Returns XY translation for positions to peform aggregation in +ve sapce\nfunction getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {\n  const {width, height} = viewport;\n\n  // Origin to define grid\n  // DEFAULT coordinate system is treated as LNGLAT\n  const worldOrigin =\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];\n\n  // Other coordinate systems not supported/verified yet\n  log.assert(\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n      coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n      coordinateSystem === COORDINATE_SYSTEM.DEFAULT\n  );\n\n  const {xMin, yMin} = boundingBox;\n  return [\n    // Align origin to match grid cell boundaries in CPU and GPU aggregations\n    -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),\n    -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])\n  ];\n}\n\n// Aligns `inValue` to given `cellSize`\nexport function alignToCell(inValue, cellSize) {\n  const sign = inValue < 0 ? -1 : 1;\n\n  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n\n  value = Math.floor(value / cellSize) * cellSize;\n\n  return value * sign;\n}\n\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} boundingBox - {xMin, yMin, xMax, yMax} contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @param {boolean, optional} converToDegrees - when true offsets are converted from meters to lng/lat (degree) space\n * @returns {xOffset, yOffset} - cellSize size\n */\n\nexport function getGridOffset(boundingBox, cellSize, convertToMeters = true) {\n  if (!convertToMeters) {\n    return {xOffset: cellSize, yOffset: cellSize};\n  }\n\n  const {yMin, yMax} = boundingBox;\n  const centerLat = (yMin + yMax) / 2;\n\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\n\nexport function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {\n  const gridOffset = getGridOffset(\n    boundingBox,\n    cellSize,\n    coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN\n  );\n\n  const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);\n\n  const {xMin, yMin, xMax, yMax} = boundingBox;\n\n  const width = xMax - xMin + gridOffset.xOffset;\n  const height = yMax - yMin + gridOffset.yOffset;\n\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n  return {gridOffset, translation, width, height, numCol, numRow};\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = calculateLatOffset(cellSize);\n  const xOffset = calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {createIterable} from '@deck.gl/core';\nimport {getGridOffset} from '../utils/grid-aggregation-utils';\n\n/**\n * Calculate density grid from an array of points\n * @param {Object} props - object containing :\n * @param {Iterable} [props.data] - data objects to be aggregated\n * @param {Integer} [props.cellSize] - size of the grid cell\n *\n * @param {Object} aggregationParams - object containing :\n * @param {Object} gridOffset - {xOffset, yOffset} cell size in meters\n * @param {Integer} width - width of the grid\n * @param {Integer} height - height of the grid\n * @param {Boolean} projectPoints - `true` if doing screen space projection, `false` otherwise\n * @param {Array} attributes - attributes array containing position values\n * @param {Viewport} viewport - viewport to be used for projection\n * @param {Array} posOffset - [xOffset, yOffset] offset to be applied to positions to get cell index\n * @param {Object} boundingBox - {xMin, yMin, xMax, yMax} bounding box of input data\n *\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n  const hashInfo = pointsToGridHashing(props, aggregationParams);\n  const result = getGridLayerDataFromGridHash(hashInfo);\n\n  return {\n    gridHash: hashInfo.gridHash,\n    gridOffset: hashInfo.gridOffset,\n    data: result\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\n/* eslint-disable max-statements, complexity */\nfunction pointsToGridHashing(props, aggregationParams) {\n  const {data = [], cellSize} = props;\n  const {attributes, viewport, projectPoints, numInstances} = aggregationParams;\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n  const boundingBox =\n    aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n  const offsets = aggregationParams.posOffset || [180, 90];\n  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n\n  const {width, height} = viewport;\n  const numCol = Math.ceil(width / gridOffset.xOffset);\n  const numRow = Math.ceil(height / gridOffset.yOffset);\n\n  // calculate count per cell\n  const gridHash = {};\n\n  const {iterable, objectInfo} = createIterable(data);\n  const position = new Array(3);\n  for (const pt of iterable) {\n    objectInfo.index++;\n    position[0] = positions[objectInfo.index * size];\n    position[1] = positions[objectInfo.index * size + 1];\n    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n    const [x, y] = projectPoints ? viewport.project(position) : position;\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n      if (\n        !projectPoints ||\n        // when doing screen space agggregation (projectPoints = true), filter points outside of the viewport range.\n        (xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow)\n      ) {\n        const key = `${yIndex}-${xIndex}`;\n\n        gridHash[key] = gridHash[key] || {count: 0, points: [], lonIdx: xIndex, latIdx: yIndex};\n        gridHash[key].count += 1;\n        gridHash[key].points.push({\n          source: pt,\n          index: objectInfo.index\n        });\n      }\n    }\n  }\n\n  return {gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1]};\n}\n/* eslint-enable max-statements, complexity */\n\nfunction getGridLayerDataFromGridHash({gridHash, gridOffset, offsets}) {\n  const data = new Array(Object.keys(gridHash).length);\n  let i = 0;\n  for (const key in gridHash) {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n    const index = i++;\n\n    data[index] = {\n      index,\n      position: [\n        offsets[0] + gridOffset.xOffset * lonIdx,\n        offsets[1] + gridOffset.yOffset * latIdx\n      ],\n      ...gridHash[key]\n    };\n  }\n  return data;\n}\n\n// Calculate bounding box of position attribute\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n  // TODO - value might not exist (e.g. attribute transition)\n  const positions = positionAttribute.value;\n  const {size} = positionAttribute.getAccessor();\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < numInstance; i++) {\n    x = positions[i * size];\n    y = positions[i * size + 1];\n    if (Number.isFinite(x) && Number.isFinite(y)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {xMin, xMax, yMin, yMax};\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport AggregationLayer, {AggregationLayerProps} from './aggregation-layer';\nimport GPUGridAggregator from './utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {Buffer} from '@luma.gl/core';\nimport {LayerContext, log, UpdateParameters} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport BinSorter from './utils/bin-sorter';\nimport {pointToDensityGridDataCPU} from './cpu-grid-layer/grid-aggregator';\n\nexport type GridAggregationLayerProps<DataT> = AggregationLayerProps<DataT>;\n\nexport default abstract class GridAggregationLayer<\n  DataT,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT> {\n  static layerName = 'GridAggregationLayer';\n\n  state!: AggregationLayer<DataT>['state'] & {\n    aggregationDataDirty?: any;\n    aggregationWeightsDirty?: any;\n    gpuAggregation?: any;\n    getValue?: () => any;\n    sortedBins?: BinSorter;\n  };\n\n  initializeAggregationLayer({dimensions}) {\n    const {gl} = this.context;\n    super.initializeAggregationLayer(dimensions);\n    this.setState({\n      // CPU aggregation results\n      layerData: {},\n      gpuGridAggregator: new GPUGridAggregator(gl, {id: `${this.id}-gpu-aggregator`}),\n      cpuGridAggregator: pointToDensityGridDataCPU\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    // get current attributes\n    super.updateState(opts);\n\n    this.updateAggregationState(opts);\n\n    const {aggregationDataDirty, aggregationWeightsDirty, gpuAggregation} = this.state;\n    if (this.getNumInstances() <= 0) {\n      return;\n    }\n    let aggregationDirty = false;\n    // CPU aggregation is two steps\n    // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n    // For GPU aggregation both above steps are combined into one step\n\n    // step-1\n    if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n      this._updateAggregation(opts);\n      aggregationDirty = true;\n    }\n    // step-2 (Applicalbe for CPU aggregation only)\n    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n      this._updateWeightBins();\n      this._uploadAggregationResults();\n      aggregationDirty = true;\n    }\n\n    this.setState({aggregationDirty});\n  }\n\n  finalizeState(context: LayerContext) {\n    const {count} = this.state.weights;\n    if (count && count.aggregationBuffer) {\n      count.aggregationBuffer.delete();\n    }\n    this.state.gpuGridAggregator?.delete();\n    super.finalizeState(context);\n  }\n\n  updateShaders(shaders: any): void {\n    if (this.state.gpuAggregation) {\n      this.state.gpuGridAggregator.updateShaders(shaders);\n    }\n  }\n\n  // Methods that can be overriden by subclasses for customizations\n\n  updateAggregationState(opts) {\n    // Sublayers should implement this method.\n    log.assert(false);\n  }\n\n  allocateResources(numRow, numCol) {\n    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n      const dataBytes = numCol * numRow * 4 * 4;\n      const gl = this.context.gl;\n      const {weights} = this.state;\n      for (const name in weights) {\n        const weight = weights[name];\n        if (weight.aggregationBuffer) {\n          weight.aggregationBuffer.delete();\n        }\n        weight.aggregationBuffer = new Buffer(gl, {\n          byteLength: dataBytes,\n          accessor: {\n            size: 4,\n            type: GL.FLOAT,\n            divisor: 1\n          }\n        });\n      }\n    }\n  }\n\n  updateResults({aggregationData, maxMinData, maxData, minData}) {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = aggregationData;\n      count.maxMinData = maxMinData;\n      count.maxData = maxData;\n      count.minData = minData;\n    }\n  }\n\n  // Private\n\n  _updateAggregation(opts) {\n    const {\n      cpuGridAggregator,\n      gpuGridAggregator,\n      gridOffset,\n      posOffset,\n      translation = [0, 0],\n      scaling = [0, 0, 0],\n      boundingBox,\n      projectPoints,\n      gpuAggregation,\n      numCol,\n      numRow\n    } = this.state;\n    const {props} = opts;\n    const {viewport} = this.context;\n    const attributes = this.getAttributes();\n    const vertexCount = this.getNumInstances();\n\n    if (!gpuAggregation) {\n      const result = cpuGridAggregator(props, {\n        gridOffset,\n        projectPoints,\n        attributes,\n        viewport,\n        posOffset,\n        boundingBox\n      });\n      this.setState({\n        layerData: result\n      });\n    } else {\n      const {weights} = this.state;\n      gpuGridAggregator.run({\n        weights,\n        cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n        numCol,\n        numRow,\n        translation,\n        scaling,\n        vertexCount,\n        projectPoints,\n        attributes,\n        moduleSettings: this.getModuleSettings()\n      });\n    }\n  }\n\n  _updateWeightBins() {\n    const {getValue} = this.state;\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {getValue});\n    this.setState({sortedBins});\n  }\n\n  _uploadAggregationResults(): void {\n    const {numCol, numRow} = this.state;\n    const {data} = this.state.layerData;\n    const {aggregatedBins, minValue, maxValue, totalCount} = this.state.sortedBins!;\n\n    const ELEMENTCOUNT = 4;\n    const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n    const aggregationData = new Float32Array(aggregationSize).fill(0);\n    for (const bin of aggregatedBins) {\n      const {lonIdx, latIdx} = data[bin.i];\n      const {value, counts} = bin;\n      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n      aggregationData[cellIndex] = value;\n      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n    }\n    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n    const minData = new Float32Array([minValue, 0, 0, totalCount]);\n    this.updateResults({aggregationData, maxMinData, maxData, minData});\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  Layer,\n  LayerContext,\n  LayersList,\n  log,\n  PickingInfo,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport type {Texture2D} from '@luma.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\nimport {getFloatTexture} from '../utils/resource-utils.js';\n\nconst defaultProps: DefaultProps<ScreenGridLayerProps> = {\n  ...ScreenGridCellLayer.defaultProps,\n  getPosition: {type: 'accessor', value: d => d.position},\n  getWeight: {type: 'accessor', value: 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\n/** All properties supported by ScreenGridLayer. */\nexport type ScreenGridLayerProps<DataT = any> = _ScreenGridLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by ScreenGridLayer. */\nexport type _ScreenGridLayerProps<DataT> = {\n  /**\n   * Unit width/height of the bins.\n   * @default 100\n   */\n  cellSizePixels?: number;\n\n  /**\n   * Cell margin size in pixels.\n   * @default 2\n   */\n  cellMarginPixels?: number;\n\n  /**\n   * Expressed as an rgba array, minimal color that could be rendered by a tile.\n   * @default [0, 0, 0, 255]\n   * @deprecated Deprecated in version 5.2.0, use `colorRange` and `colorDomain` instead.\n   */\n  minColor?: Color | null;\n\n  /**\n   * Expressed as an rgba array, maximal color that could be rendered by a tile.\n   * @default [0, 255, 0, 255]\n   * @deprecated Deprecated in version 5.2.0, use `colorRange` and `colorDomain` instead.\n   */\n  maxColor?: Color | null;\n\n  /**\n   * Color scale input domain. The color scale maps continues numeric domain into discrete color range.\n   * @default [1, max(weight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n\n  /**\n   * Perform aggregation is performed on GPU.\n   *\n   * NOTE: GPU Aggregation requires WebGL2 support by the browser.\n   * When `gpuAggregation` is set to true and browser doesn't support WebGL2, aggregation falls back to CPU.\n   *\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation\n   *\n   * V valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n};\n\n/** Aggregates data into histogram bins and renders them as a grid. */\nexport default class ScreenGridLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraProps & Required<_ScreenGridLayerProps<DataT>>> {\n  static layerName = 'ScreenGridLayer';\n  static defaultProps = defaultProps;\n\n  state!: GridAggregationLayer<DataT>['state'] & {\n    supported: boolean;\n    gpuGridAggregator?: any;\n    gpuAggregation?: any;\n    weights?: any;\n    maxTexture?: Texture2D;\n  };\n\n  initializeState() {\n    const {gl} = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      // max aggregated value is sampled from a float texture\n      this.setState({supported: false});\n      log.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS,\n      // @ts-expect-error\n      getCellSize: props => props.cellSizePixels // TODO\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {id: `${this.id}-max-texture`})\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true, // aggregation in screen space\n      weights,\n      subLayerData: {attributes: {}},\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n  }\n\n  renderLayers(): LayersList | Layer {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {maxTexture, numRow, numCol, weights} = this.state;\n    const {updateTriggers} = this.props;\n    const {aggregationBuffer} = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers\n      }),\n      {\n        data: {attributes: {instanceCounts: aggregationBuffer}},\n        maxTexture,\n        numInstances: numRow * numCol\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext): void {\n    super.finalizeState(context);\n\n    const {aggregationBuffer, maxBuffer, maxTexture} = this.state;\n\n    aggregationBuffer?.delete();\n    maxBuffer?.delete();\n    maxTexture?.delete();\n  }\n\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    const {index} = info;\n    if (index >= 0) {\n      const {gpuGridAggregator, gpuAggregation, weights} = this.state;\n      // Get count aggregation results\n      const aggregationResults = gpuAggregation\n        ? gpuGridAggregator.getData('count')\n        : weights.count;\n\n      // Each instance (one cell) is aggregated into single pixel,\n      // Get current instance's aggregation details.\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  // Aggregation Overrides\n\n  updateResults({aggregationData, maxData}) {\n    const {count} = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({data: aggregationData});\n    count.maxData = maxData;\n    count.maxTexture.setImageData({data: maxData});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {viewportChanged} = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n\n    const {dimensions} = this.state;\n    const {data, weights} = dimensions;\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      viewportChanged ||\n      this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n        dimension: data\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n\n    const {viewport} = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {width, height} = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        // transformation from clipspace to screen(pixel) space\n        scaling: [width / 2, -height / 2, 1],\n\n        gridOffset: {xOffset: cellSize, yOffset: cellSize},\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc, wrapGetValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = {...this.state, ...updateObject};\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: {\n        ...this.state.dimensions,\n        [key]: {...this.state.dimensions[key], ...updateObject}\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return {data: result.hexagons, ...result};\n    } else if (result.layerData) {\n      return {data: result.layerData, ...result};\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {data: props.data});\n        } else {\n          // If `getValue` is not provided from props, build it with aggregation and weight.\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {data: props.data});\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {updater: this.getDimensionSortedBins, ...getBins},\n      getDomain: {updater: this.getDimensionValueDomain, ...getDomain},\n      getScaleFunc: {updater: this.getDimensionScale, ...getScaleFunc},\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        // if data has changed, always update value\n        return (\n          changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged &&\n            (changeFlags.updateTriggersChanged.all ||\n              changeFlags.updateTriggersChanged[item.updateTrigger]))\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {GridCellLayer} from '@deck.gl/layers';\nimport {Accessor, AccessorFunction, Color, Position, Material, DefaultProps} from '@deck.gl/core';\n\nimport {defaultColorRange} from '../utils/color-utils';\nimport {pointToDensityGridDataCPU} from './grid-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer, {AggregationLayerProps} from '../aggregation-layer';\n\nimport {Layer, UpdateParameters, GetPickingInfoParams, PickingInfo} from '@deck.gl/core';\nimport {AggregateAccessor} from '../types';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction nop() {}\n\nconst defaultProps: DefaultProps<CPUGridLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n\n  gridAggregator: pointToDensityGridDataCPU,\n\n  // grid\n  cellSize: {type: 'number', min: 0, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true,\n\n  // data filter\n  _filterData: {type: 'function', value: null, optional: true}\n};\n\n/** All properties supported by CPUGridLayer. */\nexport type CPUGridLayerProps<DataT = any> = _CPUGridLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\n/** Properties added by CPUGridLayer. */\ntype _CPUGridLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter cells and re-calculate color by `upperPercentile`.\n   * Cells with value arger than the upperPercentile will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate color by `lowerPercentile`.\n   * Cells with value smaller than the lowerPercentile will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationUpperPercentile`.\n   * Cells with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationLowerPercentile`.\n   * Cells with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell, default value is 'quantize'.\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'linear' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell, only supports 'linear'.\n   */\n  elevationScaleType?: 'linear';\n\n  // TODO - document\n  gridAggregator?: (props: any, params: any) => any;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when bin color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when bin elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * (Experimental) Filter data objects\n   */\n  _filterData: null | ((d: DataT) => boolean);\n};\n\n/** Aggregate data into a grid-based heatmap. Aggregation is performed on CPU. */\nexport default class CPUGridLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_CPUGridLayerProps<DataT>>> {\n  static layerName = 'CPUGridLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.gridAggregator,\n      getCellSize: props => props.cellSize\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state\n    };\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'}\n    });\n    // color and elevation attributes can't be added as attributes\n    // they are calcualted using 'getValue' accessor that takes an array of pints.\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n    this.setState({\n      // make a copy of the internal state of cpuAggregator for testing\n      aggregatorState: this.state.cpuAggregator.updateState(opts, {\n        viewport: this.context.viewport,\n        attributes: this.getAttributes(),\n        numInstances: this.getNumInstances()\n      })\n    });\n  }\n\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    return this.state.cpuAggregator.getPickingInfo({info});\n  }\n\n  // create a method for testing\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n\n  // create a method for testing\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  renderLayers(): Layer {\n    const {elevationScale, extruded, cellSize, coverage, material, transitions} = this.props;\n    const {cpuAggregator} = this.state;\n    const SubLayerClass = this.getSubLayerClass('grid-cell', GridCellLayer);\n    const updateTriggers = this._getSublayerUpdateTriggers();\n\n    return new SubLayerClass(\n      {\n        cellSize,\n        coverage,\n        material,\n        elevationScale,\n        extruded,\n\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      },\n      this.getSubLayerProps({\n        id: 'grid-cell',\n        updateTriggers\n      }),\n      {\n        data: cpuAggregator.state.layerData.data\n      }\n    );\n  }\n}\n", "var thirdPi = Math.PI / 3,\n    angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];\n\nfunction pointX(d) {\n  return d[0];\n}\n\nfunction pointY(d) {\n  return d[1];\n}\n\nexport default function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 1,\n      y1 = 1,\n      x = pointX,\n      y = pointY,\n      r,\n      dx,\n      dy;\n\n  function hexbin(points) {\n    var binsById = {}, bins = [], i, n = points.length;\n\n    for (i = 0; i < n; ++i) {\n      if (isNaN(px = +x.call(null, point = points[i], i, points))\n          || isNaN(py = +y.call(null, point, i, points))) continue;\n\n      var point,\n          px,\n          py,\n          pj = Math.round(py = py / dy),\n          pi = Math.round(px = px / dx - (pj & 1) / 2),\n          py1 = py - pj;\n\n      if (Math.abs(py1) * 3 > 1) {\n        var px1 = px - pi,\n            pi2 = pi + (px < pi ? -1 : 1) / 2,\n            pj2 = pj + (py < pj ? -1 : 1),\n            px2 = px - pi2,\n            py2 = py - pj2;\n        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;\n      }\n\n      var id = pi + \"-\" + pj, bin = binsById[id];\n      if (bin) bin.push(point);\n      else {\n        bins.push(bin = binsById[id] = [point]);\n        bin.x = (pi + (pj & 1) / 2) * dx;\n        bin.y = pj * dy;\n      }\n    }\n\n    return bins;\n  }\n\n  function hexagon(radius) {\n    var x0 = 0, y0 = 0;\n    return angles.map(function(angle) {\n      var x1 = Math.sin(angle) * radius,\n          y1 = -Math.cos(angle) * radius,\n          dx = x1 - x0,\n          dy = y1 - y0;\n      x0 = x1, y0 = y1;\n      return [dx, dy];\n    });\n  }\n\n  hexbin.hexagon = function(radius) {\n    return \"m\" + hexagon(radius == null ? r : +radius).join(\"l\") + \"z\";\n  };\n\n  hexbin.centers = function() {\n    var centers = [],\n        j = Math.round(y0 / dy),\n        i = Math.round(x0 / dx);\n    for (var y = j * dy; y < y1 + r; y += dy, ++j) {\n      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {\n        centers.push([x, y]);\n      }\n    }\n    return centers;\n  };\n\n  hexbin.mesh = function() {\n    var fragment = hexagon(r).slice(0, 4).join(\"l\");\n    return hexbin.centers().map(function(p) { return \"M\" + p + \"m\" + fragment; }).join(\"\");\n  };\n\n  hexbin.x = function(_) {\n    return arguments.length ? (x = _, hexbin) : x;\n  };\n\n  hexbin.y = function(_) {\n    return arguments.length ? (y = _, hexbin) : y;\n  };\n\n  hexbin.radius = function(_) {\n    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;\n  };\n\n  hexbin.size = function(_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];\n  };\n\n  hexbin.extent = function(_) {\n    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];\n  };\n\n  return hexbin.radius(1);\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {hexbin} from 'd3-hexbin';\nimport {createIterable, log} from '@deck.gl/core';\n\n/**\n * Use d3-hexbin to performs hexagonal binning from geo points to hexagons\n * @param {Iterable} data - array of points\n * @param {Number} radius - hexagon radius in meter\n * @param {function} getPosition - get points lon lat\n * @param {Object} viewport - current viewport object\n\n * @return {Object} - hexagons and countRange\n */\nexport function pointToHexbin(props, aggregationParams) {\n  const {data, radius} = props;\n  const {viewport, attributes} = aggregationParams;\n  // get hexagon radius in mercator world unit\n  const centerLngLat = data.length ? getPointsCenter(data, aggregationParams) : null;\n  const radiusCommon = getRadiusInCommon(radius, viewport, centerLngLat);\n\n  // add world space coordinates to points\n  const screenPoints = [];\n  const {iterable, objectInfo} = createIterable(data);\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n  for (const object of iterable) {\n    objectInfo.index++;\n    const posIndex = objectInfo.index * size;\n    const position = [positions[posIndex], positions[posIndex + 1]];\n    const arrayIsFinite = Number.isFinite(position[0]) && Number.isFinite(position[1]);\n    if (arrayIsFinite) {\n      screenPoints.push({\n        screenCoord: viewport.projectFlat(position),\n        source: object,\n        index: objectInfo.index\n      });\n    } else {\n      log.warn('HexagonLayer: invalid position')();\n    }\n  }\n\n  const newHexbin = hexbin()\n    .radius(radiusCommon)\n    .x(d => d.screenCoord[0])\n    .y(d => d.screenCoord[1]);\n\n  const hexagonBins = newHexbin(screenPoints);\n\n  return {\n    hexagons: hexagonBins.map((hex, index) => ({\n      position: viewport.unprojectFlat([hex.x, hex.y]),\n      points: hex,\n      index\n    })),\n    radiusCommon\n  };\n}\n\n/**\n * Get the bounding box of all data points\n */\nexport function getPointsCenter(data, aggregationParams) {\n  const {attributes} = aggregationParams;\n  const positions = attributes.positions.value;\n  const {size} = attributes.positions.getAccessor();\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let i;\n\n  for (i = 0; i < size * data.length; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const arrayIsFinite = Number.isFinite(x) && Number.isFinite(y);\n\n    if (arrayIsFinite) {\n      minX = Math.min(x, minX);\n      maxX = Math.max(x, maxX);\n      minY = Math.min(y, minY);\n      maxY = Math.max(y, maxY);\n    }\n  }\n\n  // return center\n  return [minX, minY, maxX, maxY].every(Number.isFinite)\n    ? [(minX + maxX) / 2, (minY + maxY) / 2]\n    : null;\n}\n\n/**\n * Get radius in mercator world space coordinates from meter\n * @param {Number} radius - in meter\n * @param {Object} viewport - current viewport object\n * @param {Array<Number>} center - data center\n\n * @return {Number} radius in mercator world spcae coordinates\n */\nexport function getRadiusInCommon(radius, viewport, center) {\n  const {unitsPerMeter} = viewport.getDistanceScales(center);\n  // x, y distance should be the same\n  return radius * unitsPerMeter[0];\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  log,\n  Position,\n  Material,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\n\nimport {defaultColorRange} from '../utils/color-utils';\n\nimport {pointToHexbin} from './hexagon-aggregator';\nimport CPUAggregator from '../utils/cpu-aggregator';\nimport AggregationLayer, {AggregationLayerProps} from '../aggregation-layer';\n\nimport GL from '@luma.gl/constants';\nimport {AggregateAccessor} from '../types';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction nop() {}\n\nconst defaultProps: DefaultProps<HexagonLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calcuated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  upperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: nop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calcuated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationLowerPercentile: {type: 'number', value: 0, min: 0, max: 100},\n  elevationUpperPercentile: {type: 'number', value: 100, min: 0, max: 100},\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: nop,\n\n  radius: {type: 'number', value: 1000, min: 1},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: false,\n  hexagonAggregator: pointToHexbin,\n  getPosition: {type: 'accessor', value: x => x.position},\n  // Optional material for 'lighting' shader module\n  material: true,\n\n  // data filter\n  _filterData: {type: 'function', value: null, optional: true}\n};\n\n/** All properties supported by by HexagonLayer. */\nexport type HexagonLayerProps<DataT = any> = _HexagonLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\n/** Properties added by HexagonLayer. */\ntype _HexagonLayerProps<DataT = any> = {\n  /**\n   * Radius of hexagon bin in meters. The hexagons are pointy-topped (rather than flat-topped).\n   * @default 1000\n   */\n  radius?: number;\n\n  /**\n   * Function to aggregate data into hexagonal bins.\n   * @default d3-hexbin\n   */\n  hexagonAggregator?: (props: any, params: any) => any;\n\n  /**\n   * Color scale input domain.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Hexagon radius multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain. The elevation scale is a linear scale that maps number of counts to elevation.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Hexagon elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter bins and re-calculate color by `upperPercentile`.\n   * Hexagons with color value larger than the `upperPercentile` will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate color by `lowerPercentile`.\n   * Hexagons with color value smaller than the `lowerPercentile` will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate elevation by `elevationUpperPercentile`.\n   * Hexagons with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter bins and re-calculate elevation by `elevationLowerPercentile`.\n   * Hexagons with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell, default value is 'quantize'.\n   * Supported Values are 'quantize', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell, only supports 'linear'.\n   */\n  elevationScaleType?: 'linear';\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a bin.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into bins, this accessor is called on each cell to get the value that its color is based on.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a bin.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into bins, this accessor is called on each cell to get the value that its elevation is based on.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when cell color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when cell elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * (Experimental) Filter data objects\n   */\n  _filterData: null | ((d: DataT) => boolean);\n};\n\n/** Aggregates data into a hexagon-based heatmap. The color and height of a hexagon are determined based on the objects it contains. */\nexport default class HexagonLayer<DataT, ExtraPropsT extends {} = {}> extends AggregationLayer<\n  DataT,\n  ExtraPropsT & Required<_HexagonLayerProps<DataT>>\n> {\n  static layerName = 'HexagonLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] & {\n    cpuAggregator: CPUAggregator;\n    aggregatorState: any;\n  };\n  initializeState() {\n    const cpuAggregator = new CPUAggregator({\n      getAggregator: props => props.hexagonAggregator,\n      getCellSize: props => props.radius\n    });\n\n    this.state = {\n      cpuAggregator,\n      aggregatorState: cpuAggregator.state,\n      vertices: null\n    };\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'}\n    });\n    // color and elevation attributes can't be added as attributes\n    // they are calculated using 'getValue' accessor that takes an array of pints.\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n\n    if (opts.changeFlags.propsOrDataChanged) {\n      const aggregatorState = this.state.cpuAggregator.updateState(opts, {\n        viewport: this.context.viewport,\n        attributes: this.getAttributes()\n      });\n      if (this.state.aggregatorState.layerData !== aggregatorState.layerData) {\n        // if user provided custom aggregator and returns hexagonVertices,\n        // Need to recalculate radius and angle based on vertices\n        const {hexagonVertices} = aggregatorState.layerData || {};\n        this.setState({\n          vertices: hexagonVertices && this.convertLatLngToMeterOffset(hexagonVertices)\n        });\n      }\n\n      this.setState({\n        // make a copy of the internal state of cpuAggregator for testing\n        aggregatorState\n      });\n    }\n  }\n\n  convertLatLngToMeterOffset(hexagonVertices) {\n    const {viewport} = this.context;\n    if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n      // get centroid of hexagons\n      const vertex0 = hexagonVertices[0];\n      const vertex3 = hexagonVertices[3];\n\n      const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n      const centroidFlat = viewport.projectFlat(centroid);\n\n      const {metersPerUnit} = viewport.getDistanceScales(centroid);\n\n      // offset all points by centroid to meter offset\n      const vertices = hexagonVertices.map(vt => {\n        const vtFlat = viewport.projectFlat(vt);\n\n        return [\n          (vtFlat[0] - centroidFlat[0]) * metersPerUnit[0],\n          (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]\n        ];\n      });\n\n      return vertices;\n    }\n\n    log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n    return null;\n  }\n\n  getPickingInfo({info}) {\n    return this.state.cpuAggregator.getPickingInfo({info});\n  }\n\n  // create a method for testing\n  _onGetSublayerColor(cell) {\n    return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n  }\n\n  // create a method for testing\n  _onGetSublayerElevation(cell) {\n    return this.state.cpuAggregator.getAccessor('elevation')(cell);\n  }\n\n  _getSublayerUpdateTriggers() {\n    return this.state.cpuAggregator.getUpdateTriggers(this.props);\n  }\n\n  renderLayers() {\n    const {elevationScale, extruded, coverage, material, transitions} = this.props;\n    const {aggregatorState, vertices} = this.state;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const updateTriggers = this._getSublayerUpdateTriggers();\n\n    const geometry = vertices\n      ? {vertices, radius: 1}\n      : {\n          // default geometry\n          radius: aggregatorState.layerData.radiusCommon || 1,\n          radiusUnits: 'common',\n          angle: 90\n        };\n    return new SubLayerClass(\n      {\n        ...geometry,\n        diskResolution: 6,\n        elevationScale,\n        extruded,\n        coverage,\n        material,\n\n        getFillColor: this._onGetSublayerColor.bind(this),\n        getElevation: this._onGetSublayerElevation.bind(this),\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        }\n      },\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers\n      }),\n      {\n        data: aggregatorState.layerData.data\n      }\n    );\n  }\n}\n", "// Code to Offsets Map needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\n// Table to map code to the intersection offsets\n// All offsets are relative to the center of marching cell (which is top right corner of grid-cell, and center of marching-square)\nconst HALF = 0.5;\nconst ONE6TH = 1 / 6;\nconst OFFSET = {\n  N: [0, HALF], // NORTH\n  E: [HALF, 0], // EAST\n  S: [0, -HALF], // SOUTH\n  W: [-HALF, 0], // WEST\n\n  // CORNERS\n  NE: [HALF, HALF],\n  NW: [-HALF, HALF],\n  SE: [HALF, -HALF],\n  SW: [-HALF, -HALF]\n};\n\n// NOTE: vertices are ordered in CCW direction, starting from NW corner\n\n// Triangles\nconst SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];\nconst SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];\nconst NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];\n\n// Trapezoids\nconst SW_TRAPEZOID = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF]\n];\nconst SE_TRAPEZOID = [\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH]\n];\nconst NE_TRAPEZOID = [\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\nconst NW_TRAPEZOID = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Rectangles\nconst S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];\nconst E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];\nconst W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];\nconst EW_RECTANGEL = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH]\n];\nconst SN_RECTANGEL = [\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Square\nconst SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];\n\n// Pentagons\nconst SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];\nconst SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];\nconst NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];\n\nconst NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];\nconst SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];\n\nconst NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];\nconst NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];\n\n// Hexagon\nconst S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];\nconst W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];\n\n// Heptagon (7-sided)\nconst NE_HEPTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  OFFSET.E,\n  OFFSET.NE,\n  OFFSET.N\n];\nconst SW_HEPTAGON = [\n  OFFSET.W,\n  OFFSET.SW,\n  OFFSET.S,\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\nconst NW_HEPTAGON = [\n  OFFSET.NW,\n  OFFSET.W,\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  OFFSET.N\n];\nconst SE_HEPTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  OFFSET.S,\n  OFFSET.SE,\n  OFFSET.E,\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Octagon\nconst OCTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Note: above wiki page invertes white/black dots for generating the code, we don't\nexport const ISOLINES_CODE_OFFSET_MAP = {\n  // key is equal to the code of 4 vertices (invert the code specified in wiki)\n  // value can be an array or an Object\n  // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]\n  // Object : to handle saddle cases, whos output depends on mean value of all 4 corners\n  //  key: code of mean value (0 or 1)\n  //  value: Array , as above defines one or two line segments\n  0: [],\n  1: [[OFFSET.W, OFFSET.S]],\n  2: [[OFFSET.S, OFFSET.E]],\n  3: [[OFFSET.W, OFFSET.E]],\n  4: [[OFFSET.N, OFFSET.E]],\n  5: {\n    0: [\n      [OFFSET.W, OFFSET.S],\n      [OFFSET.N, OFFSET.E]\n    ],\n    1: [\n      [OFFSET.W, OFFSET.N],\n      [OFFSET.S, OFFSET.E]\n    ]\n  },\n  6: [[OFFSET.N, OFFSET.S]],\n  7: [[OFFSET.W, OFFSET.N]],\n  8: [[OFFSET.W, OFFSET.N]],\n  9: [[OFFSET.N, OFFSET.S]],\n  10: {\n    0: [\n      [OFFSET.W, OFFSET.N],\n      [OFFSET.S, OFFSET.E]\n    ],\n    1: [\n      [OFFSET.W, OFFSET.S],\n      [OFFSET.N, OFFSET.E]\n    ]\n  },\n  11: [[OFFSET.N, OFFSET.E]],\n  12: [[OFFSET.W, OFFSET.E]],\n  13: [[OFFSET.S, OFFSET.E]],\n  14: [[OFFSET.W, OFFSET.S]],\n  15: []\n};\n\nfunction ternaryToIndex(ternary) {\n  return parseInt(ternary, 4);\n}\n\nexport const ISOBANDS_CODE_OFFSET_MAP = {\n  // Below list of cases, follow the same order as in above mentioned wiki page.\n  // Each case has its code on first commented line // T,TR,R,C\n  // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2\n  // final code is binary representation of above code , where takes 2 digits\n  // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169\n\n  // no contours\n  [ternaryToIndex('0000')]: [],\n  [ternaryToIndex('2222')]: [],\n\n  // single triangle\n  [ternaryToIndex('2221')]: [SW_TRIANGLE],\n  [ternaryToIndex('2212')]: [SE_TRIANGLE],\n  [ternaryToIndex('2122')]: [NE_TRIANGLE],\n  [ternaryToIndex('1222')]: [NW_TRIANGLE],\n  [ternaryToIndex('0001')]: [SW_TRIANGLE],\n  [ternaryToIndex('0010')]: [SE_TRIANGLE],\n  [ternaryToIndex('0100')]: [NE_TRIANGLE],\n  [ternaryToIndex('1000')]: [NW_TRIANGLE],\n\n  // single trapezoid\n  [ternaryToIndex('2220')]: [SW_TRAPEZOID],\n  [ternaryToIndex('2202')]: [SE_TRAPEZOID],\n  [ternaryToIndex('2022')]: [NE_TRAPEZOID],\n  [ternaryToIndex('0222')]: [NW_TRAPEZOID],\n  [ternaryToIndex('0002')]: [SW_TRAPEZOID],\n  [ternaryToIndex('0020')]: [SE_TRAPEZOID],\n  [ternaryToIndex('0200')]: [NE_TRAPEZOID],\n  [ternaryToIndex('2000')]: [NW_TRAPEZOID],\n\n  // single rectangle\n  [ternaryToIndex('0011')]: [S_RECTANGLE],\n  [ternaryToIndex('0110')]: [E_RECTANGLE],\n  [ternaryToIndex('1100')]: [N_RECTANGLE],\n  [ternaryToIndex('1001')]: [W_RECTANGLE],\n  [ternaryToIndex('2211')]: [S_RECTANGLE],\n  [ternaryToIndex('2112')]: [E_RECTANGLE],\n  [ternaryToIndex('1122')]: [N_RECTANGLE],\n  [ternaryToIndex('1221')]: [W_RECTANGLE],\n  [ternaryToIndex('2200')]: [EW_RECTANGEL],\n  [ternaryToIndex('2002')]: [SN_RECTANGEL],\n  [ternaryToIndex('0022')]: [EW_RECTANGEL],\n  [ternaryToIndex('0220')]: [SN_RECTANGEL],\n\n  // single square\n  // 1111\n  [ternaryToIndex('1111')]: [SQUARE],\n\n  // single pentagon\n  [ternaryToIndex('1211')]: [SW_PENTAGON],\n  [ternaryToIndex('2111')]: [SE_PENTAGON],\n  [ternaryToIndex('1112')]: [NE_PENTAGON],\n  [ternaryToIndex('1121')]: [NW_PENTAGON],\n  [ternaryToIndex('1011')]: [SW_PENTAGON],\n  [ternaryToIndex('0111')]: [SE_PENTAGON],\n  [ternaryToIndex('1110')]: [NE_PENTAGON],\n  [ternaryToIndex('1101')]: [NW_PENTAGON],\n  [ternaryToIndex('1200')]: [NW_N_PENTAGON],\n  [ternaryToIndex('0120')]: [NE_E_PENTAGON],\n  [ternaryToIndex('0012')]: [SE_S_PENTAGON],\n  [ternaryToIndex('2001')]: [SW_W_PENTAGON],\n  [ternaryToIndex('1022')]: [NW_N_PENTAGON],\n  [ternaryToIndex('2102')]: [NE_E_PENTAGON],\n  [ternaryToIndex('2210')]: [SE_S_PENTAGON],\n  [ternaryToIndex('0221')]: [SW_W_PENTAGON],\n  [ternaryToIndex('1002')]: [NW_W_PENTAGON],\n  [ternaryToIndex('2100')]: [NE_N_PENTAGON],\n  [ternaryToIndex('0210')]: [SE_E_PENTAGON],\n  [ternaryToIndex('0021')]: [SW_S_PENTAGON],\n  [ternaryToIndex('1220')]: [NW_W_PENTAGON],\n  [ternaryToIndex('0122')]: [NE_N_PENTAGON],\n  [ternaryToIndex('2012')]: [SE_E_PENTAGON],\n  [ternaryToIndex('2201')]: [SW_S_PENTAGON],\n\n  // single hexagon\n  [ternaryToIndex('0211')]: [S_HEXAGON],\n  [ternaryToIndex('2110')]: [E_HEXAGON],\n  [ternaryToIndex('1102')]: [N_HEXAGON],\n  [ternaryToIndex('1021')]: [W_HEXAGON],\n  [ternaryToIndex('2011')]: [S_HEXAGON],\n  [ternaryToIndex('0112')]: [E_HEXAGON],\n  [ternaryToIndex('1120')]: [N_HEXAGON],\n  [ternaryToIndex('1201')]: [W_HEXAGON],\n  [ternaryToIndex('2101')]: [SW_NE_HEXAGON],\n  [ternaryToIndex('0121')]: [SW_NE_HEXAGON],\n  [ternaryToIndex('1012')]: [NW_SE_HEXAGON],\n  [ternaryToIndex('1210')]: [NW_SE_HEXAGON],\n\n  // 6-sided polygons based on mean weight\n  // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)\n  [ternaryToIndex('0101')]: {\n    0: [SW_TRIANGLE, NE_TRIANGLE],\n    1: [SW_NE_HEXAGON],\n    2: [SW_NE_HEXAGON]\n  },\n  [ternaryToIndex('1010')]: {\n    0: [NW_TRIANGLE, SE_TRIANGLE],\n    1: [NW_SE_HEXAGON],\n    2: [NW_SE_HEXAGON]\n  },\n  [ternaryToIndex('2121')]: {\n    0: [SW_NE_HEXAGON],\n    1: [SW_NE_HEXAGON],\n    2: [SW_TRIANGLE, NE_TRIANGLE]\n  },\n  [ternaryToIndex('1212')]: {\n    0: [NW_SE_HEXAGON],\n    1: [NW_SE_HEXAGON],\n    2: [NW_TRIANGLE, SE_TRIANGLE]\n  },\n\n  // 7-sided polygons based on mean weight\n  [ternaryToIndex('2120')]: {\n    0: [NE_HEPTAGON],\n    1: [NE_HEPTAGON],\n    2: [SW_TRAPEZOID, NE_TRIANGLE]\n  },\n  [ternaryToIndex('2021')]: {\n    0: [SW_HEPTAGON],\n    1: [SW_HEPTAGON],\n    2: [SW_TRIANGLE, NE_TRAPEZOID]\n  },\n  [ternaryToIndex('1202')]: {\n    0: [NW_HEPTAGON],\n    1: [NW_HEPTAGON],\n    2: [NW_TRIANGLE, SE_TRAPEZOID]\n  },\n  [ternaryToIndex('0212')]: {\n    0: [SE_HEPTAGON],\n    1: [SE_HEPTAGON],\n    2: [SE_TRIANGLE, NW_TRAPEZOID]\n  },\n  [ternaryToIndex('0102')]: {\n    0: [SW_TRAPEZOID, NE_TRIANGLE],\n    1: [NE_HEPTAGON],\n    2: [NE_HEPTAGON]\n  },\n  [ternaryToIndex('0201')]: {\n    0: [SW_TRIANGLE, NE_TRAPEZOID],\n    1: [SW_HEPTAGON],\n    2: [SW_HEPTAGON]\n  },\n  [ternaryToIndex('1020')]: {\n    0: [NW_TRIANGLE, SE_TRAPEZOID],\n    1: [NW_HEPTAGON],\n    2: [NW_HEPTAGON]\n  },\n  [ternaryToIndex('2010')]: {\n    0: [SE_TRIANGLE, NW_TRAPEZOID],\n    1: [SE_HEPTAGON],\n    2: [SE_HEPTAGON]\n  },\n\n  // 8-sided polygons based on mean weight\n  [ternaryToIndex('2020')]: {\n    0: [NW_TRAPEZOID, SE_TRAPEZOID],\n    1: [OCTAGON],\n    2: [SW_TRAPEZOID, NE_TRAPEZOID]\n  },\n  [ternaryToIndex('0202')]: {\n    0: [NE_TRAPEZOID, SW_TRAPEZOID],\n    1: [OCTAGON],\n    2: [NW_TRAPEZOID, SE_TRAPEZOID]\n  }\n};\n", "// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\nimport {log} from '@deck.gl/core';\nimport {ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP} from './marching-squares-codes';\n\nexport const CONTOUR_TYPE = {\n  ISO_LINES: 1,\n  ISO_BANDS: 2\n};\n\nconst DEFAULT_THRESHOLD_DATA = {\n  zIndex: 0,\n  zOffset: 0.005\n};\n\n// Utility methods\n\nfunction getVertexCode(weight: number, threshold: number | number[]): number {\n  // threshold must be a single value or a range (array of size 2)\n\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {cellWeights, x, y, width, height} = opts;\n  let threshold = opts.threshold;\n  if (opts.thresholdValue) {\n    log.deprecated('thresholdValue', 'threshold')();\n    threshold = opts.thresholdValue;\n  }\n\n  const isLeftBoundary = x < 0;\n  const isRightBoundary = x >= width - 1;\n  const isBottomBoundary = y < 0;\n  const isTopBoundary = y >= height - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n\n  const weights: Record<string, number> = {};\n  const codes: Record<string, number> = {};\n\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    codes.top = 0;\n  } else {\n    weights.top = cellWeights[(y + 1) * width + x];\n    codes.top = getVertexCode(weights.top, threshold);\n  }\n\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    codes.topRight = 0;\n  } else {\n    weights.topRight = cellWeights[(y + 1) * width + x + 1];\n    codes.topRight = getVertexCode(weights.topRight, threshold);\n  }\n\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    codes.right = 0;\n  } else {\n    weights.right = cellWeights[y * width + x + 1];\n    codes.right = getVertexCode(weights.right, threshold);\n  }\n\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    codes.current = 0;\n  } else {\n    weights.current = cellWeights[y * width + x];\n    codes.current = getVertexCode(weights.current, threshold);\n  }\n\n  const {top, topRight, right, current} = codes;\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = (top << 3) | (topRight << 2) | (right << 1) | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = (top << 6) | (topRight << 4) | (right << 2) | current;\n  }\n\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(\n      (weights.top + weights.topRight + weights.right + weights.current) / 4,\n      threshold\n    );\n  }\n  return {code, meanCode};\n}\n/* eslint-enable complexity, max-statements*/\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getVertices(opts) {\n  const {gridOrigin, cellSize, x, y, code, meanCode, type = CONTOUR_TYPE.ISO_LINES} = opts;\n  const thresholdData = {...DEFAULT_THRESHOLD_DATA, ...opts.thresholdData};\n  let offsets =\n    type === CONTOUR_TYPE.ISO_BANDS\n      ? ISOBANDS_CODE_OFFSET_MAP[code]\n      : ISOLINES_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n\n  const vZ = thresholdData.zIndex * thresholdData.zOffset;\n  const rX = (x + 1) * cellSize[0];\n  const rY = (y + 1) * cellSize[1];\n\n  const refVertexX = gridOrigin[0] + rX;\n  const refVertexY = gridOrigin[1] + rY;\n\n  // offsets format\n  // ISO_LINES: [[1A, 1B], [2A, 2B]],\n  // ISO_BANDS: [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n\n  // vertices format\n\n  // ISO_LINES: [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n\n  // ISO_BANDS:  => confirms to SolidPolygonLayer's simple polygon format\n  //      [\n  //        [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  //      ]\n\n  if (type === CONTOUR_TYPE.ISO_BANDS) {\n    const polygons: number[][][] = [];\n    offsets.forEach(polygonOffsets => {\n      const polygon: number[][] = [];\n      polygonOffsets.forEach(xyOffset => {\n        const vX = refVertexX + xyOffset[0] * cellSize[0];\n        const vY = refVertexY + xyOffset[1] * cellSize[1];\n        polygon.push([vX, vY, vZ]);\n      });\n      polygons.push(polygon);\n    });\n    return polygons;\n  }\n\n  // default case is ISO_LINES\n  const lines: number[][] = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = refVertexX + offset[0] * cellSize[0];\n      const vY = refVertexY + offset[1] * cellSize[1];\n      lines.push([vX, vY, vZ]);\n    });\n  });\n  return lines;\n}\n", "import {getCode, getVertices, CONTOUR_TYPE} from './marching-squares';\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  thresholdData,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}: {\n  thresholdData: any;\n  cellWeights: Float32Array;\n  gridSize: number[];\n  gridOrigin: number[];\n  cellSize: number[];\n}) {\n  const contourSegments: {start: number[]; end: number[]; contour: any}[] = [];\n  const contourPolygons: {vertices: number[][]; contour: any}[] = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {contour} = data;\n    const {threshold} = contour;\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          type: CONTOUR_TYPE.ISO_BANDS,\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts) as number[][][];\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // Get the intersection vertices based on MarchingSquares code.\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts) as number[][];\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {contourSegments, contourPolygons};\n}\n/* eslint-enable max-depth */\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {LineLayer, SolidPolygonLayer} from '@deck.gl/layers';\nimport {generateContours} from './contour-utils';\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  Layer,\n  log,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\n\nconst defaultProps: DefaultProps<ContourLayerProps> = {\n  // grid aggregation\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  gpuAggregation: true,\n  aggregation: 'SUM',\n\n  // contour lines\n  contours: {\n    type: 'object',\n    value: [{threshold: DEFAULT_THRESHOLD}],\n    optional: true,\n    compare: 3\n  },\n\n  zOffset: 0.005\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\n/** All properties supported by ContourLayer. */\nexport type ContourLayerProps<DataT = any> = _ContourLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by ContourLayer. */\nexport type _ContourLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Definition of contours to be drawn.\n   * @default [{threshold: 1}]\n   */\n  contours: {\n    /**\n     * Isolines: `threshold` value must be a single `Number`, Isolines are generated based on this threshold value.\n     *\n     * Isobands: `threshold` value must be an Array of two `Number`s. Isobands are generated using `[threshold[0], threshold[1])` as threshold range, i.e area that has values `>= threshold[0]` and `< threshold[1]` are rendered with corresponding color. NOTE: `threshold[0]` is inclusive and `threshold[1]` is not inclusive.\n     */\n    threshold: number | number[];\n\n    /**\n     * RGBA color array to be used to render the contour.\n     * @default [255, 255, 255, 255]\n     */\n    color?: Color;\n\n    /**\n     * Applicable for `Isoline`s only, width of the Isoline in pixels.\n     * @default 1\n     */\n    strokeWidth?: number;\n\n    /** Defines z order of the contour. */\n    zIndex?: number;\n  }[];\n\n  /**\n   * A very small z offset that is added for each vertex of a contour (Isoline or Isoband).\n   * @default 0.005\n   */\n  zOffset?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\n/** Aggregate data into iso-lines or iso-bands for a given threshold and cell size. */\nexport default class ContourLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraPropsT & Required<_ContourLayerProps<DataT>>> {\n  static layerName = 'ContourLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      contourData: {},\n      projectPoints: false,\n      weights: {\n        count: {\n          size: 1,\n          operation: AGGREGATION_OPERATION.SUM\n        }\n      }\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>): void {\n    super.updateState(opts);\n    let contoursChanged = false;\n    const {oldProps, props} = opts;\n    const {aggregationDirty} = this.state;\n\n    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n      contoursChanged = true;\n      this._updateThresholdData(opts.props);\n    }\n\n    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n      this._generateContours();\n    }\n  }\n\n  renderLayers(): Layer[] {\n    const {contourSegments, contourPolygons} = this.state.contourData;\n\n    const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n\n    // Contour lines layer\n    const lineLayer =\n      contourSegments &&\n      contourSegments.length > 0 &&\n      new LinesSubLayerClass(\n        this.getSubLayerProps({\n          id: 'lines'\n        }),\n        {\n          data: this.state.contourData.contourSegments,\n          getSourcePosition: d => d.start,\n          getTargetPosition: d => d.end,\n          getColor: d => d.contour.color || DEFAULT_COLOR,\n          getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n        }\n      );\n\n    // Contour bands layer\n    const bandsLayer =\n      contourPolygons &&\n      contourPolygons.length > 0 &&\n      new BandsSubLayerClass(\n        this.getSubLayerProps({\n          id: 'bands'\n        }),\n        {\n          data: this.state.contourData.contourPolygons,\n          getPolygon: d => d.vertices,\n          getFillColor: d => d.contour.color || DEFAULT_COLOR\n        }\n      );\n\n    return [lineLayer, bandsLayer];\n  }\n\n  // Aggregation Overrides\n\n  /* eslint-disable max-statements, complexity */\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    let gpuAggregation = props.gpuAggregation;\n    if (this.state.gpuAggregation !== props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const {dimensions} = this.state;\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {data, weights} = dimensions;\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        boundingBox,\n        translation,\n        posOffset: translation.slice(), // Used for CPU aggregation, to offset points\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: data,\n        compareAll: gpuAggregation // check for all (including extentions props) when using gpu aggregation\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n  }\n  /* eslint-enable max-statements, complexity */\n\n  // Private (Aggregation)\n\n  private _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  private _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n  // Private (Contours)\n\n  private _generateContours() {\n    const {numCol, numRow, gridOrigin, gridOffset, thresholdData} = this.state;\n    const {count} = this.state.weights;\n    let {aggregationData} = count;\n    if (!aggregationData) {\n      aggregationData = count.aggregationBuffer.getData();\n      count.aggregationData = aggregationData;\n    }\n\n    const {cellWeights} = GPUGridAggregator.getCellData({countsData: aggregationData});\n    const contourData = generateContours({\n      thresholdData,\n      cellWeights,\n      gridSize: [numCol, numRow],\n      gridOrigin,\n      cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n    });\n\n    // contourData contains both iso-lines and iso-bands if requested.\n    this.setState({contourData});\n  }\n\n  private _updateThresholdData(props) {\n    const {contours, zOffset} = props;\n    const count = contours.length;\n    const thresholdData = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const contour = contours[i];\n      thresholdData[i] = {\n        contour,\n        zIndex: contour.zIndex || i,\n        zOffset\n      };\n    }\n    this.setState({thresholdData});\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Inspired by screen-grid-layer vertex shader in deck.gl\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-vertex-shader\n#define RANGE_COUNT 6\n\nin vec3 positions;\nin vec3 normals;\n\nin vec4 colors;\nin vec4 elevations;\nin vec3 instancePickingColors;\n\n// Custom uniforms\nuniform vec2 offset;\nuniform bool extruded;\nuniform float cellSize;\nuniform float coverage;\nuniform float opacity;\nuniform float elevationScale;\n\nuniform ivec2 gridSize;\nuniform vec2 gridOrigin;\nuniform vec2 gridOriginLow;\nuniform vec2 gridOffset;\nuniform vec2 gridOffsetLow;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 elevationRange;\n\n// Domain uniforms\nuniform vec2 colorDomain;\nuniform bool colorDomainValid;\nuniform vec2 elevationDomain;\nuniform bool elevationDomainValid;\n\nlayout(std140) uniform;\nuniform ColorData\n{\n  vec4 maxMinCount;\n} colorData;\nuniform ElevationData\n{\n  vec4 maxMinCount;\n} elevationData;\n\n#define EPSILON 0.00001\n\n// Result\nout vec4 vColor;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  return outColor;\n}\n\nfloat linearScale(vec2 domain, vec2 range, float value) {\n  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\n    return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;\n  }\n  return -1.;\n}\n\nvoid main(void) {\n  vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);\n  vec4 color = quantizeScale(clrDomain, colorRange, colors.r);\n\n  float elevation = 0.0;\n\n  if (extruded) {\n    vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);\n    elevation = linearScale(elvDomain, elevationRange, elevations.r);\n    elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;\n  }\n\n  // if aggregated color or elevation is 0 do not render\n  float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);\n  float dotRadius = cellSize / 2. * coverage * shouldRender;\n\n  int yIndex = (gl_InstanceID / gridSize[0]);\n  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);\n\n  vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));\n  instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));\n  vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));\n  instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));\n\n  vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);\n  vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);\n  geometry.worldPosition = centroidPosition;\n  vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n\n  // Light calculations\n  // Worldspace is the linear space after Mercator projection\n\n  vec3 normals_commonspace = project_normal(normals);\n\n   if (extruded) {\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);\n    vColor = vec4(lightColor, color.a * opacity) / 255.;\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity) / 255.;\n  }\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-fragment-shader\n\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vColor;\n  fragColor = picking_filterColor(fragColor);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Layer,\n  fp64LowPart,\n  project32,\n  gouraudLighting,\n  picking,\n  LayerContext,\n  LayerProps,\n  DefaultProps\n} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, CubeGeometry, Buffer} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport type {_GPUGridLayerProps} from './gpu-grid-layer';\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\n\nconst COLOR_DATA_UBO_INDEX = 0;\nconst ELEVATION_DATA_UBO_INDEX = 1;\n\nconst defaultProps: DefaultProps<_GPUGridCellLayerProps & LayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  gridSize: {type: 'array', value: [1, 1]},\n  gridOrigin: {type: 'array', value: [0, 0]},\n  gridOffset: {type: 'array', value: [0, 0]},\n\n  cellSize: {type: 'number', min: 0, max: 1000, value: 1000},\n  offset: {type: 'array', value: [1, 1]},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  extruded: true,\n\n  material: true // Use lighting module defaults\n};\n\ntype _GPUGridCellLayerProps = _GPUGridLayerProps<any> & {\n  offset: number[];\n  gridSize: number[];\n  gridOrigin: number[];\n  gridOffset: number[];\n  colorMaxMinBuffer: Buffer;\n  elevationMaxMinBuffer: Buffer;\n};\n\nexport default class GPUGridCellLayer extends Layer<_GPUGridCellLayerProps> {\n  static layerName = 'GPUGridCellLayer';\n  static defaultProps = defaultProps;\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudLighting, picking, fp64arithmetic]\n    });\n  }\n\n  initializeState({gl}: LayerContext) {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.addInstanced({\n      colors: {\n        size: 4,\n        noAlloc: true\n      },\n      elevations: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n    const model = this._getModel(gl);\n    this._setupUniformBuffer(model);\n    this.setState({model});\n  }\n\n  _getModel(gl: WebGLRenderingContext): Model {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new CubeGeometry(),\n      isInstanced: true\n    });\n  }\n\n  draw({uniforms}) {\n    const {\n      cellSize,\n      offset,\n      extruded,\n      elevationScale,\n      coverage,\n      gridSize,\n      gridOrigin,\n      gridOffset,\n      elevationRange,\n      colorMaxMinBuffer,\n      elevationMaxMinBuffer\n    } = this.props;\n\n    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n    const domainUniforms = this.getDomainUniforms();\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms(domainUniforms)\n      .setUniforms({\n        cellSize,\n        offset,\n        extruded,\n        elevationScale,\n        coverage,\n        gridSize,\n        gridOrigin,\n        gridOriginLow,\n        gridOffset,\n        gridOffsetLow,\n        colorRange,\n        elevationRange\n      })\n      .draw();\n    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n  }\n\n  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.bind({target: GL.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});\n    elevationMaxMinBuffer.bind({target: GL.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});\n  }\n\n  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n    colorMaxMinBuffer.unbind({target: GL.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX});\n    elevationMaxMinBuffer.unbind({target: GL.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX});\n  }\n\n  getDomainUniforms() {\n    const {colorDomain, elevationDomain} = this.props;\n    const domainUniforms: Record<string, any> = {};\n    if (colorDomain !== null) {\n      domainUniforms.colorDomainValid = true;\n      domainUniforms.colorDomain = colorDomain;\n    } else {\n      domainUniforms.colorDomainValid = false;\n    }\n    if (elevationDomain !== null) {\n      domainUniforms.elevationDomainValid = true;\n      domainUniforms.elevationDomain = elevationDomain;\n    } else {\n      domainUniforms.elevationDomainValid = false;\n    }\n    return domainUniforms;\n  }\n\n  private _setupUniformBuffer(model: Model): void {\n    const gl = this.context.gl as WebGL2RenderingContext;\n    const programHandle = model.program.handle;\n\n    const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n    const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {\n  Accessor,\n  AccessorFunction,\n  Color,\n  Material,\n  GetPickingInfoParams,\n  LayerContext,\n  log,\n  PickingInfo,\n  Position,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION} from '../utils/aggregation-operation-utils';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport {pointToDensityGridDataCPU} from './../cpu-grid-layer/grid-aggregator';\nimport GridAggregationLayer, {GridAggregationLayerProps} from '../grid-aggregation-layer';\nimport {getBoundingBox, getGridParams} from '../utils/grid-aggregation-utils';\n\nconst defaultProps: DefaultProps<GPUGridLayerProps> = {\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // grid\n  cellSize: {type: 'number', min: 1, max: 1000, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: x => x.position},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n// This layer only perform GPU aggregation, no need to seperate data and weight props\n// aggregation will be dirty when any of the props are changed.\n\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n  }\n  // rest of the changes are detected by `state.attributesChanged`\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n\n/** All properties supported by GPUGridLayer. */\nexport type GPUGridLayerProps<DataT = any> = _GPUGridLayerProps<DataT> &\n  GridAggregationLayerProps<DataT>;\n\n/** Properties added by GPUGridLayer. */\nexport type _GPUGridLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * @default 'SUM'\n   */\n  colorAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * @default 'SUM'\n   */\n  elevationAggregation?: 'SUM' | 'MEAN' | 'MIN' | 'MAX';\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n};\n\n/** Aggregate data into a grid-based heatmap. Aggregation is performed on GPU (WebGL2 only). */\nexport default class GPUGridLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends GridAggregationLayer<DataT, ExtraPropsT & Required<_GPUGridLayerProps<DataT>>> {\n  static layerName = 'GPUGridLayer';\n  static defaultProps = defaultProps;\n\n  initializeState({gl}: LayerContext): void {\n    const isSupported = GPUGridAggregator.isSupported(gl);\n    if (!isSupported) {\n      log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n    }\n    super.initializeAggregationLayer({\n      dimensions: DIMENSIONS\n    });\n    this.setState({\n      gpuAggregation: true,\n      projectPoints: false, // aggregation in world space\n      isSupported,\n      weights: {\n        color: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        },\n        elevation: {\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true,\n          maxMinBuffer: new Buffer(gl, {\n            byteLength: 4 * 4,\n            accessor: {size: 4, type: GL.FLOAT, divisor: 1}\n          })\n        }\n      },\n      positionAttributeName: 'positions'\n    });\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      color: {size: 3, accessor: 'getColorWeight'},\n      elevation: {size: 3, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(opts) {\n    if (this.state.isSupported === false) {\n      // Skip update, layer not supported\n      return;\n    }\n    super.updateState(opts);\n    const {aggregationDirty} = this.state;\n    if (aggregationDirty) {\n      // reset cached CPU Aggregation results (used for picking)\n      this.setState({\n        gridHash: null\n      });\n    }\n  }\n\n  getHashKeyForIndex(index: number): string {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    // This will match the index to the hash-key to access aggregation data from CPU aggregation results.\n    const latIdx = Math.floor(\n      (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]\n    );\n    const lonIdx = Math.floor(\n      (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]\n    );\n    return `${latIdx}-${lonIdx}`;\n  }\n\n  getPositionForIndex(index: number): Position {\n    const {numRow, numCol, boundingBox, gridOffset} = this.state;\n    const gridSize = [numCol, numRow];\n    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n    const yIndex = Math.floor(index / gridSize[0]);\n    const xIndex = index - yIndex * gridSize[0];\n    const yPos = yIndex * cellSize[1] + gridOrigin[1];\n    const xPos = xIndex * cellSize[0] + gridOrigin[0];\n    return [xPos, yPos];\n  }\n\n  getPickingInfo({info, mode}: GetPickingInfoParams): PickingInfo {\n    const {index} = info;\n    let object: any = null;\n    if (index >= 0) {\n      const {gpuGridAggregator} = this.state;\n      const position = this.getPositionForIndex(index);\n      const colorInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('color')\n      });\n      const elevationInfo = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...gpuGridAggregator.getData('elevation')\n      });\n\n      object = {\n        colorValue: colorInfo.cellWeight,\n        elevationValue: elevationInfo.cellWeight,\n        count: colorInfo.cellCount || elevationInfo.cellCount,\n        position,\n        totalCount: colorInfo.totalCount || elevationInfo.totalCount\n      };\n      if (mode !== 'hover') {\n        // perform CPU aggregation for full list of points for each cell\n        const {props} = this;\n        let {gridHash} = this.state;\n        if (!gridHash) {\n          const {gridOffset, translation, boundingBox} = this.state;\n          const {viewport} = this.context;\n          const attributes = this.getAttributes();\n          const cpuAggregation = pointToDensityGridDataCPU(props as any, {\n            gridOffset,\n            attributes,\n            viewport,\n            translation,\n            boundingBox\n          });\n          gridHash = cpuAggregation.gridHash;\n          this.setState({gridHash});\n        }\n        const key = this.getHashKeyForIndex(index);\n        const cpuAggregationData = gridHash[key];\n        Object.assign(object, cpuAggregationData);\n      }\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  renderLayers() {\n    if (!this.state.isSupported) {\n      return null;\n    }\n    const {\n      elevationScale,\n      extruded,\n      cellSize: cellSizeMeters,\n      coverage,\n      material,\n      elevationRange,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n\n    const {weights, numRow, numCol, gridOrigin, gridOffset} = this.state;\n    const {color, elevation} = weights;\n    const colorRange = colorRangeToFlatArray(this.props.colorRange);\n\n    const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n\n    return new SubLayerClass(\n      {\n        gridSize: [numCol, numRow],\n        gridOrigin,\n        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n        colorRange,\n        elevationRange,\n        colorDomain,\n        elevationDomain,\n\n        cellSize: cellSizeMeters,\n        coverage,\n        material,\n        elevationScale,\n        extruded\n      },\n      this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }),\n      {\n        data: {\n          attributes: {\n            colors: color.aggregationBuffer,\n            elevations: elevation.aggregationBuffer\n          }\n        },\n        colorMaxMinBuffer: color.maxMinBuffer,\n        elevationMaxMinBuffer: elevation.maxMinBuffer,\n        numInstances: numCol * numRow\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext) {\n    const {color, elevation} = this.state.weights;\n    [color, elevation].forEach(weight => {\n      const {aggregationBuffer, maxMinBuffer} = weight;\n      maxMinBuffer.delete();\n      aggregationBuffer?.delete();\n    });\n    super.finalizeState(context);\n  }\n\n  // Aggregation Overrides\n\n  updateAggregationState(opts) {\n    const {props, oldProps} = opts;\n    const {cellSize, coordinateSystem} = props;\n    const {viewport} = this.context;\n    const cellSizeChanged = oldProps.cellSize !== cellSize;\n    const {dimensions} = this.state;\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    // any attribute changed\n    const attributesChanged = positionsChanged || this.isAttributeChanged();\n\n    let {boundingBox} = this.state;\n    if (positionsChanged) {\n      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n      this.setState({boundingBox});\n    }\n    if (positionsChanged || cellSizeChanged) {\n      const {gridOffset, translation, width, height, numCol, numRow} = getGridParams(\n        boundingBox,\n        cellSize,\n        viewport,\n        coordinateSystem\n      );\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        gridOffset,\n        translation,\n        gridOrigin: [-1 * translation[0], -1 * translation[1]],\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    const aggregationDataDirty =\n      attributesChanged ||\n      this.isAggregationDirty(opts, {\n        dimension: dimensions.data,\n        compareAll: true\n      });\n\n    if (aggregationDataDirty) {\n      this._updateAccessors(opts);\n    }\n    this.setState({\n      aggregationDataDirty\n    });\n  }\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {colorAggregation, elevationAggregation} = opts.props;\n    const {color, elevation} = this.state.weights;\n    color.operation = AGGREGATION_OPERATION[colorAggregation];\n    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n  }\n}\n", "import {\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport GPUGridLayer, {GPUGridLayerProps} from '../gpu-grid-layer/gpu-grid-layer';\nimport CPUGridLayer, {CPUGridLayerProps} from '../cpu-grid-layer/cpu-grid-layer';\n\nconst defaultProps: DefaultProps<GridLayerProps> = {\n  ...GPUGridLayer.defaultProps,\n  ...CPUGridLayer.defaultProps,\n  gpuAggregation: false\n};\n\n/** All properties supported by GridLayer. */\nexport type GridLayerProps<DataT = any> = _GridLayerProps<DataT> & CompositeLayerProps;\n\n/** Properties added by GridLayer. */\ntype _GridLayerProps<DataT> = CPUGridLayerProps<DataT> &\n  GPUGridLayerProps<DataT> & {\n    /**\n     * Whether the aggregation should be performed in high-precision 64-bit mode.\n     * @default false\n     */\n    fp64?: boolean;\n\n    /**\n     * When set to true, aggregation is performed on GPU, provided other conditions are met.\n     * @default false\n     */\n    gpuAggregation?: boolean;\n  };\n\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class GridLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_GridLayerProps<DataT>>\n> {\n  static layerName = 'GridLayer';\n  static defaultProps = defaultProps;\n\n  state!: CompositeLayer['state'] & {\n    useGPUAggregation: boolean;\n  };\n\n  initializeState() {\n    this.state = {\n      useGPUAggregation: true\n    };\n  }\n\n  updateState({props}: UpdateParameters<this>) {\n    this.setState({\n      useGPUAggregation: this.canUseGPUAggregation(props)\n    });\n  }\n\n  renderLayers(): Layer {\n    const {data, updateTriggers} = this.props;\n    const id = this.state.useGPUAggregation ? 'GPU' : 'CPU';\n    const LayerType = this.state.useGPUAggregation\n      ? this.getSubLayerClass('GPU', GPUGridLayer)\n      : this.getSubLayerClass('CPU', CPUGridLayer);\n    return new LayerType(\n      this.props,\n      this.getSubLayerProps({\n        id,\n        updateTriggers\n      }),\n      {\n        data\n      }\n    );\n  }\n\n  // Private methods\n\n  canUseGPUAggregation(props: GridLayer['props']) {\n    const {\n      gpuAggregation,\n      lowerPercentile,\n      upperPercentile,\n      getColorValue,\n      getElevationValue,\n      colorScaleType\n    } = props;\n    if (!gpuAggregation) {\n      // cpu aggregation is requested\n      return false;\n    }\n    if (!GPUGridAggregator.isSupported(this.context.gl)) {\n      return false;\n    }\n    if (lowerPercentile !== 0 || upperPercentile !== 100) {\n      // percentile calculations requires sorting not supported on GPU\n      return false;\n    }\n    if (getColorValue !== null || getElevationValue !== null) {\n      // accessor for custom color or elevation calculation is specified\n      return false;\n    }\n    if (colorScaleType === 'quantile' || colorScaleType === 'ordinal') {\n      // quantile and ordinal scales are not supported on GPU\n      return false;\n    }\n    return true;\n  }\n}\n", "import GL from '@luma.gl/constants';\nimport {isWebGL2} from '@luma.gl/core';\n\nexport function getBounds(points: number[][]): number[] {\n  // Now build bounding box in world space (aligned to world coordiante system)\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n\n  return [xMin, yMin, xMax, yMax];\n}\n\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds: number[], targetBounds: number[]): boolean {\n  if (\n    targetBounds[0] >= currentBounds[0] &&\n    targetBounds[2] <= currentBounds[2] &&\n    targetBounds[1] >= currentBounds[1] &&\n    targetBounds[3] <= currentBounds[3]\n  ) {\n    return true;\n  }\n  return false;\n}\n\nconst scratchArray = new Float32Array(12);\n\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points: number[][], dimensions: number = 2): Float32Array {\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\n\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(boundingBox: number[], width: number, height: number): number[] {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    // expand bounding box width\n    newWidth = (width / height) * currentHeight;\n  } else {\n    newHeight = (height / width) * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n\n  return [\n    xCenter - newWidth / 2,\n    yCenter - newHeight / 2,\n    xCenter + newWidth / 2,\n    yCenter + newHeight / 2\n  ];\n}\n\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point: number[], bounds: number[]) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n\n// Returns format and type for creating texture objects\nexport function getTextureParams({gl, floatTargetSupport}) {\n  return floatTargetSupport\n    ? {\n        // format:  should be RGBA32F on WebGL2 (float textures), RGBA in WebGL1 for float or non float textures\n        format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n        type: GL.FLOAT\n      }\n    : {\n        format: GL.RGBA,\n        type: GL.UNSIGNED_BYTE\n      };\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Inspired by screen-grid-layer vertex shader in deck.gl\n\nexport default `\\\n#define SHADER_NAME heatp-map-layer-vertex-shader\n\nuniform sampler2D maxTexture;\nuniform float intensity;\nuniform vec2 colorDomain;\nuniform float threshold;\nuniform float aggregationMode;\n\nattribute vec3 positions;\nattribute vec2 texCoords;\n\nvarying vec2 vTexCoords;\nvarying float vIntensityMin;\nvarying float vIntensityMax;\n\nvoid main(void) {\n  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));\n  vTexCoords = texCoords;\n  vec4 maxTexture = texture2D(maxTexture, vec2(0.5));\n  float maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;\n  float minValue = maxValue * threshold;\n  if (colorDomain[1] > 0.) {\n    // if user specified custom domain use it.\n    maxValue = colorDomain[1];\n    minValue = colorDomain[0];\n  }\n  vIntensityMax = intensity / maxValue;\n  vIntensityMin = intensity / minValue;\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME triangle-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D texture;\nuniform sampler2D colorTexture;\nuniform float aggregationMode;\n\nvarying vec2 vTexCoords;\nvarying float vIntensityMin;\nvarying float vIntensityMax;\n\nvec4 getLinearColor(float value) {\n  float factor = clamp(value * vIntensityMax, 0., 1.);\n  vec4 color = texture2D(colorTexture, vec2(factor, 0.5));\n  color.a *= min(value * vIntensityMin, 1.0);\n  return color;\n}\n\nvoid main(void) {\n  vec4 weights = texture2D(texture, vTexCoords);\n  float weight = weights.r;\n\n  if (aggregationMode > 0.5) {\n    weight /= max(1.0, weights.a);\n  }\n\n  // discard pixels with 0 weight.\n  if (weight <= 0.) {\n     discard;\n  }\n\n  vec4 linearColor = getLinearColor(weight);\n  linearColor.a *= opacity;\n  gl_FragColor =linearColor;\n}\n`;\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, Texture2D} from '@luma.gl/core';\nimport {Layer, LayerContext, project32} from '@deck.gl/core';\nimport vs from './triangle-layer-vertex.glsl';\nimport fs from './triangle-layer-fragment.glsl';\n\ntype _TriangleLayerProps = {\n  colorDomain: number[];\n  aggregationMode: string;\n  threshold: number;\n  intensity: number;\n  vertexCount: number;\n  colorTexture: Texture2D;\n  maxTexture: Texture2D;\n  texture: Texture2D;\n};\n\nexport default class TriangleLayer extends Layer<_TriangleLayerProps> {\n  static layerName = 'TriangleLayer';\n\n  getShaders() {\n    return {vs, fs, modules: [project32]};\n  }\n\n  initializeState({gl}: LayerContext): void {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, noAlloc: true},\n      texCoords: {size: 2, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  _getModel(gl: WebGLRenderingContext): Model {\n    const {vertexCount} = this.props;\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        vertexCount\n      })\n    });\n  }\n\n  draw({uniforms}): void {\n    const {model} = this.state;\n\n    const {texture, maxTexture, colorTexture, intensity, threshold, aggregationMode, colorDomain} =\n      this.props;\n\n    model\n      .setUniforms({\n        ...uniforms,\n        texture,\n        maxTexture,\n        colorTexture,\n        intensity,\n        threshold,\n        aggregationMode,\n        colorDomain\n      })\n      .draw();\n  }\n}\n", "export default `\\\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float weights;\nvarying vec4 weightsTexture;\nuniform float radiusPixels;\nuniform float textureWidth;\nuniform vec4 commonBounds;\nuniform float weightsScale;\nvoid main()\n{\n  weightsTexture = vec4(weights * weightsScale, 0., 0., 1.);\n\n  float radiusTexels  = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);\n  gl_PointSize = radiusTexels * 2.;\n\n  vec3 commonPosition = project_position(positions, positions64Low);\n\n  // map xy from commonBounds to [-1, 1]\n  gl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;\n  gl_Position.xy = (gl_Position.xy * 2.) - (1.);\n}\n`;\n", "export default `\\\nvarying vec4 weightsTexture;\n// Epanechnikov function, keeping for reference\n// float epanechnikovKDE(float u) {\n//   return 0.75 * (1.0 - u * u);\n// }\nfloat gaussianKDE(float u){\n  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);\n}\nvoid main()\n{\n  float dist = length(gl_PointCoord - vec2(0.5, 0.5));\n  if (dist > 0.5) {\n    discard;\n  }\n  gl_FragColor = weightsTexture * gaussianKDE(2. * dist);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "export default `\\\nattribute vec4 inTexture;\nvarying vec4 outTexture;\n\nvoid main()\n{\noutTexture = inTexture;\ngl_Position = vec4(0, 0, 0, 1.);\n// Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\ngl_PointSize = 1.0;\n}\n`;\n", "export default `\\\nvarying vec4 outTexture;\nvoid main() {\n  gl_FragColor = outTexture;\n  gl_FragColor.g = outTexture.r / max(1.0, outTexture.a);\n}\n`;\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global setTimeout clearTimeout */\nimport GL from '@luma.gl/constants';\nimport {\n  getBounds,\n  boundsContain,\n  packVertices,\n  scaleToAspectRatio,\n  getTextureCoordinates,\n  getTextureParams\n} from './heatmap-layer-utils';\nimport {\n  Buffer,\n  Texture2D,\n  Transform,\n  getParameters,\n  withParameters,\n  FEATURES,\n  hasFeatures\n} from '@luma.gl/core';\nimport {\n  Accessor,\n  AccessorFunction,\n  AttributeManager,\n  ChangeFlags,\n  Color,\n  COORDINATE_SYSTEM,\n  Layer,\n  LayerContext,\n  LayersList,\n  log,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport TriangleLayer from './triangle-layer';\nimport AggregationLayer, {AggregationLayerProps} from '../aggregation-layer';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport weightsVs from './weights-vs.glsl';\nimport weightsFs from './weights-fs.glsl';\nimport vsMax from './max-vs.glsl';\nimport fsMax from './max-fs.glsl';\n\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_OPTIONS = {\n  mipmaps: false,\n  parameters: {\n    [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n    [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n    [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n    [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n  },\n  dataFormat: GL.RGBA\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\n\nconst defaultProps: DefaultProps<HeatmapLayerProps> = {\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  intensity: {type: 'number', min: 0, value: 1},\n  radiusPixels: {type: 'number', min: 1, max: 100, value: 50},\n  colorRange: defaultColorRange,\n  threshold: {type: 'number', min: 0, max: 1, value: 0.05},\n  colorDomain: {type: 'array', value: null, optional: true},\n  // 'SUM' or 'MEAN'\n  aggregation: 'SUM',\n  weightsTextureSize: {type: 'number', min: 128, max: 2048, value: 2048},\n  debounceTimeout: {type: 'number', min: 0, max: 1000, value: 500}\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.BLEND_EQUATION_MINMAX, // max weight calculation\n  FEATURES.TEXTURE_FLOAT // weight-map as texture\n];\n\nconst FLOAT_TARGET_FEATURES = [\n  FEATURES.COLOR_ATTACHMENT_RGBA32F, // ability to render to float texture\n  FEATURES.FLOAT_BLEND // ability to blend when rendering to float texture\n];\n\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\n\nexport type HeatmapLayerProps<DataT = any> = _HeatmapLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\ntype _HeatmapLayerProps<DataT> = {\n  /**\n   * Radius of the circle in pixels, to which the weight of an object is distributed.\n   *\n   * @default 30\n   */\n  radiusPixels?: number;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Value that is multiplied with the total weight at a pixel to obtain the final weight.\n   *\n   * @default 1\n   */\n  intensity?: number;\n\n  /**\n   * Ratio of the fading weight to the max weight, between `0` and `1`.\n   *\n   * For example, `0.1` affects all pixels with weight under 10% of the max.\n   *\n   * Ignored when `colorDomain` is specified.\n   * @default 0.05\n   */\n  threshold?: number;\n\n  /**\n   * Controls how weight values are mapped to the `colorRange`, as an array of two numbers [`minValue`, `maxValue`].\n   *\n   * @default null\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Defines the type of aggregation operation\n   *\n   * V valid values are 'SUM', 'MEAN'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN';\n\n  /**\n   * Specifies the size of weight texture.\n   * @default 2048\n   */\n  weightsTextureSize?: number;\n\n  /**\n   * Interval in milliseconds during which changes to the viewport don't trigger aggregation.\n   *\n   * @default 500\n   */\n  debounceTimeout?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\n/** Visualizes the spatial distribution of data. */\nexport default class HeatmapLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_HeatmapLayerProps<DataT>>> {\n  static layerName = 'HeatmapLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] & {\n    supported: boolean;\n    colorDomain?: number[];\n    isWeightMapDirty?: boolean;\n    weightsTexture?: Texture2D;\n    zoom?: number;\n    worldBounds?: number[];\n    normalizedCommonBounds?: number[];\n    updateTimer?: any;\n    triPositionBuffer?: Buffer;\n    triTexCoordBuffer?: Buffer;\n  };\n\n  initializeState() {\n    const {gl} = this.context;\n    if (!hasFeatures(gl, REQUIRED_FEATURES)) {\n      this.setState({supported: false});\n      log.error(`HeatmapLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeAggregationLayer(DIMENSIONS);\n    this.setState({supported: true, colorDomain: DEFAULT_COLOR_DOMAIN});\n    this._setupTextureParams();\n    this._setupAttributes();\n    this._setupResources();\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    // Need to be updated when viewport changes\n    return changeFlags.somethingChanged;\n  }\n\n  /* eslint-disable max-statements,complexity */\n  updateState(opts: UpdateParameters<this>) {\n    if (!this.state.supported) {\n      return;\n    }\n    super.updateState(opts);\n    this._updateHeatmapState(opts);\n  }\n\n  _updateHeatmapState(opts: UpdateParameters<this>) {\n    const {props, oldProps} = opts;\n    const changeFlags = this._getChangeFlags(opts);\n\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      // if data is changed, do not debounce and immediately update the weight map\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n      this._updateTextureRenderingBounds();\n    }\n\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      // Update weight map immediately\n      clearTimeout(this.state.updateTimer);\n      this.setState({isWeightMapDirty: true});\n    } else if (changeFlags.viewportZoomChanged) {\n      // Update weight map when zoom stops\n      this._debouncedUpdateWeightmap();\n    }\n\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n\n    this.setState({zoom: opts.context.viewport.zoom});\n  }\n\n  renderLayers(): LayersList | Layer {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {updateTriggers, intensity, threshold, aggregation} = this.props;\n\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n\n    return new TriangleLayerClass(\n      this.getSubLayerProps({\n        id: 'triangle-layer',\n        updateTriggers\n      }),\n      {\n        // position buffer is filled with world coordinates generated from viewport.unproject\n        // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n        coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n        data: {\n          attributes: {\n            positions: triPositionBuffer,\n            texCoords: triTexCoordBuffer\n          }\n        },\n        vertexCount: 4,\n        maxTexture: maxWeightsTexture,\n        colorTexture,\n        aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n        texture: weightsTexture,\n        intensity,\n        threshold,\n        colorDomain\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform?.delete();\n    weightsTexture?.delete();\n    maxWeightTransform?.delete();\n    maxWeightsTexture?.delete();\n    triPositionBuffer?.delete();\n    triTexCoordBuffer?.delete();\n    colorTexture?.delete();\n    if (updateTimer) {\n      clearTimeout(updateTimer);\n    }\n  }\n\n  // PRIVATE\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n  _getChangeFlags(opts: UpdateParameters<this>) {\n    const changeFlags: Partial<ChangeFlags> & {\n      boundsChanged?: boolean;\n      viewportZoomChanged?: boolean;\n    } = {};\n    const {dimensions} = this.state;\n    changeFlags.dataChanged =\n      this.isAttributeChanged() || // if any attribute is changed\n      this.isAggregationDirty(opts, {\n        compareAll: true,\n        dimension: dimensions.data\n      });\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n\n    const {zoom} = this.state;\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n\n    return changeFlags;\n  }\n\n  _createTextures() {\n    const {gl} = this.context;\n    const {textureSize, format, type} = this.state;\n\n    this.setState({\n      weightsTexture: new Texture2D(gl, {\n        width: textureSize,\n        height: textureSize,\n        format,\n        type,\n        ...TEXTURE_OPTIONS\n      }),\n      maxWeightsTexture: new Texture2D(gl, {format, type, ...TEXTURE_OPTIONS}) // 1 X 1 texture,\n    });\n  }\n\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'},\n      weights: {size: 1, accessor: 'getWeight'}\n    });\n    this.setState({positionAttributeName: 'positions'});\n  }\n\n  _setupTextureParams() {\n    const {gl} = this.context;\n    const {weightsTextureSize} = this.props;\n\n    const textureSize = Math.min(weightsTextureSize, getParameters(gl, gl.MAX_TEXTURE_SIZE));\n    const floatTargetSupport = hasFeatures(gl, FLOAT_TARGET_FEATURES);\n    const {format, type} = getTextureParams({gl, floatTargetSupport});\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({textureSize, format, type, weightsScale});\n    if (!floatTargetSupport) {\n      log.warn(\n        `HeatmapLayer: ${this.id} rendering to float texture not supported, fallingback to low precession format`\n      )();\n    }\n  }\n\n  getShaders(type) {\n    return super.getShaders(\n      type === 'max-weights-transform'\n        ? {\n            vs: vsMax,\n            _fs: fsMax\n          }\n        : {\n            vs: weightsVs,\n            _fs: weightsFs\n          }\n    );\n  }\n\n  _createWeightsTransform(shaders = {}) {\n    const {gl} = this.context;\n    let {weightsTransform} = this.state;\n    const {weightsTexture} = this.state;\n    weightsTransform?.delete();\n\n    weightsTransform = new Transform(gl, {\n      id: `${this.id}-weights-transform`,\n      elementCount: 1,\n      _targetTexture: weightsTexture,\n      _targetTextureVarying: 'weightsTexture',\n      ...shaders\n    });\n    this.setState({weightsTransform});\n  }\n\n  _setupResources() {\n    const {gl} = this.context;\n    this._createTextures();\n    const {textureSize, weightsTexture, maxWeightsTexture} = this.state;\n\n    const weightsTransformShaders = this.getShaders('weights-transform');\n    this._createWeightsTransform(weightsTransformShaders);\n\n    const maxWeightsTransformShaders = this.getShaders('max-weights-transform');\n    const maxWeightTransform = new Transform(gl, {\n      id: `${this.id}-max-weights-transform`,\n      _sourceTextures: {\n        inTexture: weightsTexture\n      },\n      _targetTexture: maxWeightsTexture,\n      _targetTextureVarying: 'outTexture',\n      ...maxWeightsTransformShaders,\n      elementCount: textureSize * textureSize\n    });\n\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {size: 3}\n      }),\n      triTexCoordBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {size: 2}\n      })\n    });\n  }\n\n  // overwrite super class method to update transform model\n  updateShaders(shaderOptions) {\n    // sahder params (modules, injects) changed, update model object\n    this._createWeightsTransform(shaderOptions);\n  }\n\n  _updateMaxWeightValue() {\n    const {maxWeightTransform} = this.state;\n    maxWeightTransform.run({\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: GL.MAX\n      }\n    });\n  }\n\n  // Computes world bounds area that needs to be processed for generate heatmap\n  _updateBounds(forceUpdate: any = false): boolean {\n    const {viewport} = this.context;\n\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n    const viewportCorners = [\n      viewport.unproject([0, 0]),\n      viewport.unproject([viewport.width, 0]),\n      viewport.unproject([viewport.width, viewport.height]),\n      viewport.unproject([0, viewport.height])\n    ].map(p => p.map(Math.fround));\n\n    // #1: get world bounds for current viewport extends\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n\n    const newState: Partial<HeatmapLayer['state']> = {visibleWorldBounds, viewportCorners};\n    let boundsChanged = false;\n\n    if (\n      forceUpdate ||\n      !this.state.worldBounds ||\n      !boundsContain(this.state.worldBounds, visibleWorldBounds)\n    ) {\n      // #2 : convert world bounds to common (Flat) bounds\n      // #3 : extend common bounds to match aspect ratio with viewport\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n\n      // #4 :convert aligned common bounds to world bounds\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n\n      // Clip webmercator projection limits\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n\n      boundsChanged = true;\n    }\n    this.setState(newState);\n    return boundsChanged;\n  }\n\n  _updateTextureRenderingBounds() {\n    // Just render visible portion of the texture\n    const {triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners} =\n      this.state;\n\n    const {viewport} = this.context;\n\n    triPositionBuffer.subData(packVertices(viewportCorners, 3));\n\n    const textureBounds = viewportCorners.map(p =>\n      getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds!)\n    );\n    triTexCoordBuffer.subData(packVertices(textureBounds, 2));\n  }\n\n  _updateColorTexture(opts) {\n    const {colorRange} = opts.props;\n    let {colorTexture} = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array as any);\n\n    if (colorTexture) {\n      colorTexture.setImageData({\n        data: colors,\n        width: colorRange.length\n      });\n    } else {\n      colorTexture = new Texture2D(this.context.gl, {\n        data: colors,\n        width: colorRange.length,\n        height: 1,\n        ...TEXTURE_OPTIONS\n      });\n    }\n    this.setState({colorTexture});\n  }\n\n  _updateWeightmap() {\n    const {radiusPixels, colorDomain, aggregation} = this.props;\n    const {weightsTransform, worldBounds, textureSize, weightsTexture, weightsScale} = this.state;\n    this.state.isWeightMapDirty = false;\n\n    // convert world bounds to common using Layer's coordiante system and origin\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n\n    if (colorDomain && aggregation === 'SUM') {\n      // scale color domain to weight per pixel\n      const {viewport} = this.context;\n      const metersPerPixel =\n        (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\n        textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n\n    const uniforms = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale\n    };\n    // Attribute manager sets data array count as instaceCount on model\n    // we need to set that as elementCount on 'weightsTransform'\n    weightsTransform.update({\n      elementCount: this.getNumInstances()\n    });\n    // Need to explictly specify clearColor as external context may have modified it\n    withParameters(this.context.gl, {clearColor: [0, 0, 0, 0]}, () => {\n      weightsTransform.run({\n        uniforms,\n        parameters: {\n          blend: true,\n          depthTest: false,\n          blendFunc: [GL.ONE, GL.ONE],\n          blendEquation: GL.FUNC_ADD\n        },\n        clearRenderTarget: true,\n        attributes: this.getAttributes(),\n        moduleSettings: this.getModuleSettings()\n      });\n    });\n    this._updateMaxWeightValue();\n\n    // reset filtering parameters (TODO: remove once luma issue#1193 is fixed)\n    weightsTexture.setParameters({\n      [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n      [GL.TEXTURE_MIN_FILTER]: GL.LINEAR\n    });\n  }\n\n  _debouncedUpdateWeightmap(fromTimer = false) {\n    let {updateTimer} = this.state;\n    const {debounceTimeout} = this.props;\n\n    if (fromTimer) {\n      updateTimer = null;\n      // update\n      this._updateBounds(true);\n      this._updateTextureRenderingBounds();\n      this.setState({isWeightMapDirty: true});\n    } else {\n      this.setState({isWeightMapDirty: false});\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n\n    this.setState({updateTimer});\n  }\n\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n  _worldToCommonBounds(worldBounds, opts: {useLayerCoordinateSystem?: boolean} = {}) {\n    const {useLayerCoordinateSystem = false} = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {viewport} = this.context;\n    const {textureSize} = this.state;\n    const {coordinateSystem} = this.props;\n\n    const offsetMode =\n      useLayerCoordinateSystem &&\n      (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n        coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode\n      ? viewport.projectPosition(this.props.coordinateOrigin)\n      : [0, 0];\n    const size = (textureSize * RESOLUTION) / viewport.scale;\n\n    let bottomLeftCommon;\n    let topRightCommon;\n\n    // Y-axis is flipped between World and Common bounds\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n    // Ignore z component\n    return scaleToAspectRatio(\n      [\n        bottomLeftCommon[0] - offsetOriginCommon[0],\n        bottomLeftCommon[1] - offsetOriginCommon[1],\n        topRightCommon[0] - offsetOriginCommon[0],\n        topRightCommon[1] - offsetOriginCommon[1]\n      ],\n      size,\n      size\n    );\n  }\n\n  // input commonBounds: [xMin, yMin, xMax, yMax]\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {viewport} = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n}\n"],
  "mappings": "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",
  "names": ["AGGREGATION_OPERATION", "SUM", "MEAN", "MIN", "MAX", "sumReducer", "accu", "cur", "maxReducer", "minReducer", "getMean", "pts", "accessor", "Number", "isFinite", "length", "filtered", "map", "filter", "reduce", "getSum", "getMax", "getMin", "Infinity", "getValueFunc", "aggregation", "context", "op", "wrapAccessor", "pt", "index", "source", "wrapGetValueFunc", "getValue", "indices", "DEFAULT_RUN_PARAMS", "projectPoints", "viewport", "createBufferObjects", "moduleSettings", "MAX_32_BIT_FLOAT", "MIN_BLEND_EQUATION", "MAX_BLEND_EQUATION", "MAX_MIN_BLEND_EQUATION", "EQUATION_MAP", "AGGREGATION_OPERATION", "SUM", "MEAN", "MIN", "MAX", "DEFAULT_WEIGHT_PARAMS", "size", "operation", "AGGREGATION_OPERATION", "SUM", "needMin", "needMax", "combineMaxMin", "PIXEL_SIZE", "DEFAULT_PARAMETERS", "getFloatTexture", "gl", "opts", "width", "height", "data", "unpackFlipY", "parameters", "texture", "Texture2D", "format", "isWebGL2", "type", "border", "mipmaps", "dataFormat", "getFramebuffer", "id", "fb", "Framebuffer", "attachments", "BUFFER_NAMES", "ARRAY_BUFFER_MAP", "maxData", "minData", "maxMinData", "REQUIRED_FEATURES", "FEATURES", "WEBGL2", "COLOR_ATTACHMENT_RGBA32F", "BLEND_EQUATION_MINMAX", "FLOAT_BLEND", "TEXTURE_FLOAT", "GPUGridAggregator", "getAggregationData", "aggregationData", "pixelIndex", "index", "PIXEL_SIZE", "results", "cellCount", "cellWeight", "maxCellWieght", "minCellWeight", "totalCount", "getCellData", "countsData", "size", "numCells", "length", "cellWeights", "Float32Array", "cellCounts", "Uint32Array", "i", "sizeIndex", "isSupported", "gl", "hasFeatures", "constructor", "opts", "id", "state", "weightAttributes", "textures", "meanTextures", "buffers", "framebuffers", "maxMinFramebuffers", "minFramebuffers", "maxFramebuffers", "equations", "resources", "_hasGPUSupport", "isWebGL2", "_setupModels", "delete", "gridAggregationModel", "allAggregationModel", "meanTransform", "deleteResources", "run", "setState", "aggregationParams", "_normalizeAggregationParams", "log", "_runAggregation", "getData", "weightId", "data", "aggregationBuffer", "arrayName", "bufferName", "updateShaders", "shaderOptions", "modelDirty", "DEFAULT_RUN_PARAMS", "weights", "normalizeWeightParams", "updateObject", "Object", "assign", "_getAggregateData", "needMin", "needMax", "combineMaxMin", "aggregationTexture", "readPixelsToBuffer", "target", "sourceType", "maxMinBuffer", "maxMinTexture", "minBuffer", "minTexture", "maxBuffer", "maxTexture", "_trackGPUResultBuffers", "_renderAggregateData", "cellSize", "projectPoints", "attributes", "moduleSettings", "numCol", "numRow", "translation", "scaling", "gridSize", "parameters", "blend", "depthTest", "blendFunc", "uniforms", "_renderToWeightsTexture", "_renderToMaxMinTexture", "blendEquation", "MAX_MIN_BLEND_EQUATION", "minOrMaxFb", "clearParams", "clearColor", "MAX_32_BIT_FLOAT", "MIN_BLEND_EQUATION", "MAX_BLEND_EQUATION", "withParameters", "framebuffer", "viewport", "clear", "draw", "uSampler", "texture", "operation", "AGGREGATION_OPERATION", "MIN", "MEAN", "transformOptions", "_sourceTextures", "aggregationValues", "_targetTexture", "elementCount", "width", "height", "update", "getMeanTransform", "attach", "_updateModels", "_setupFramebuffers", "framebufferSize", "getFloatTexture", "resize", "getFramebuffer", "EQUATION_MAP", "SUM", "_getMinMaxTexture", "name", "getAggregationModel", "instanceCount", "getAllAggregationModel", "_setupWeightAttributes", "vertexCount", "setVertexCount", "setAttributes", "setInstanceCount", "result", "DEFAULT_WEIGHT_PARAMS", "Array", "isArray", "forEach", "obj", "shaders", "mergeShaders", "vs", "AGGREGATE_TO_GRID_VS", "fs", "AGGREGATE_TO_GRID_FS", "modules", "fp64arithmetic", "project32", "Model", "drawMode", "AGGREGATE_ALL_VS", "AGGREGATE_ALL_FS", "isInstanced", "position", "Transform", "TRANSFORM_MEAN_VS", "_targetTextureVarying", "defaultColorRange", "colorRangeToFlatArray", "colorRange", "normalize", "ArrayType", "Float32Array", "flatArray", "Number", "isFinite", "length", "index", "i", "color", "DEFAULT_MINCOLOR", "DEFAULT_MAXCOLOR", "COLOR_PROPS", "defaultProps", "cellSizePixels", "value", "min", "cellMarginPixels", "max", "colorDomain", "colorRange", "defaultColorRange", "ScreenGridCellLayer", "Layer", "isSupported", "gl", "hasFeatures", "FEATURES", "TEXTURE_FLOAT", "getShaders", "vs", "fs", "modules", "picking", "initializeState", "context", "attributeManager", "getAttributeManager", "addInstanced", "instancePositions", "size", "update", "calculateInstancePositions", "instanceCounts", "noAlloc", "setState", "model", "_getModel", "shouldUpdateState", "changeFlags", "somethingChanged", "updateState", "params", "oldProps", "props", "numInstances", "invalidateAll", "invalidate", "_updateUniforms", "draw", "uniforms", "parameters", "maxTexture", "minColor", "maxColor", "state", "setUniforms", "depthTest", "depthMask", "attribute", "width", "height", "viewport", "numCol", "Math", "ceil", "i", "x", "y", "floor", "Model", "id", "geometry", "Geometry", "drawMode", "attributes", "positions", "Float32Array", "isInstanced", "_shouldUseMinMax", "log", "deprecated", "some", "key", "shouldUseMinMax", "colorRangeToFlatArray", "viewportChanged", "margin", "cellScale", "filterProps", "props", "filterKeys", "filteredProps", "key", "includes", "AggregationLayer", "CompositeLayer", "initializeAggregationLayer", "dimensions", "initializeState", "context", "setState", "ignoreProps", "filterProps", "constructor", "_propTypes", "data", "props", "updateState", "opts", "changeFlags", "extensionsChanged", "shaders", "getShaders", "defines", "NON_INSTANCED_MODEL", "updateShaders", "_updateAttributes", "updateAttributes", "changedAttributes", "getAttributes", "getAttributeManager", "getShaderAttributes", "getModuleSettings", "viewport", "mousePosition", "gl", "moduleSettings", "Object", "assign", "create", "pickingActive", "devicePixelRatio", "cssToDeviceRatio", "isAggregationDirty", "updateOpts", "params", "oldProps", "compareAll", "dimension", "state", "dataProps", "accessors", "updateTriggersChanged", "dataChanged", "all", "accessor", "compareProps", "newProps", "propTypes", "name", "isAttributeChanged", "isObjectEmpty", "undefined", "_getAttributeManager", "AttributeManager", "id", "stats", "obj", "isEmpty", "key", "getScale", "domain", "range", "scaleFunction", "scale", "getQuantizeScale", "value", "quantizeScale", "getLinearScale", "linearScale", "getQuantileScale", "sortedDomain", "sort", "ascending", "i", "n", "Math", "max", "length", "thresholds", "Array", "threshold", "thresholdsScale", "a", "b", "fraction", "domainLength", "domainFraction", "lowIndex", "floor", "low", "high", "bisectRight", "x", "lo", "hi", "mid", "ordinalScale", "domainMap", "key", "d", "get", "undefined", "push", "set", "getOrdinalScale", "Map", "uniqueDomain", "has", "domainRange", "log", "warn", "step", "idx", "clampIdx", "min", "notNullOrUndefined", "unique", "values", "results", "forEach", "v", "includes", "getTruthyValues", "data", "valueAccessor", "map", "filter", "getQuantileDomain", "data", "valueAccessor", "getTruthyValues", "getOrdinalDomain", "unique", "clamp", "value", "min", "max", "Math", "getScaleFunctionByScaleType", "scaleType", "getQuantizeScale", "getLinearScale", "getQuantileScale", "getOrdinalScale", "defaultGetValue", "points", "length", "MAX_32_BIT_FLOAT", "defaultGetPoints", "bin", "defaultGetIndex", "index", "ascending", "a", "b", "NaN", "defaultProps", "getValue", "getPoints", "getIndex", "filterData", "BinSorter", "constructor", "bins", "props", "aggregatedBins", "getAggregatedBins", "_updateMinMaxValues", "binMap", "getBinMap", "hasFilter", "binCount", "binIndex", "i", "filteredPoints", "filter", "value", "undefined", "Number", "isFinite", "counts", "_percentileToIndex", "percentileRange", "len", "sortedBins", "lower", "upper", "map", "n", "clamp", "lowerIdx", "Math", "ceil", "upperIdx", "floor", "maxCount", "maxValue", "minValue", "totalCount", "x", "getValueRange", "sort", "Array", "isArray", "idxRange", "getValueDomainByScale", "scale", "indexEdge", "_getScaleDomain", "scaleType", "getQuantileDomain", "slice", "d", "getOrdinalDomain", "R_EARTH", "toFinite", "n", "Number", "isFinite", "getBoundingBox", "attributes", "vertexCount", "positions", "value", "yMin", "Infinity", "yMax", "xMin", "xMax", "y", "x", "i", "boundingBox", "getTranslation", "gridOffset", "coordinateSystem", "viewport", "width", "height", "worldOrigin", "COORDINATE_SYSTEM", "CARTESIAN", "log", "assert", "LNGLAT", "DEFAULT", "alignToCell", "xOffset", "yOffset", "inValue", "cellSize", "sign", "Math", "abs", "floor", "getGridOffset", "convertToMeters", "centerLat", "calculateGridLatLonOffset", "getGridParams", "translation", "numCol", "ceil", "numRow", "latitude", "calculateLatOffset", "calculateLonOffset", "dy", "PI", "lat", "dx", "cos", "pointToDensityGridDataCPU", "props", "aggregationParams", "hashInfo", "pointsToGridHashing", "result", "getGridLayerDataFromGridHash", "gridHash", "gridOffset", "data", "cellSize", "attributes", "viewport", "projectPoints", "numInstances", "positions", "value", "size", "getAccessor", "boundingBox", "getPositionBoundingBox", "offsets", "posOffset", "getGridOffset", "xOffset", "yOffset", "width", "height", "numCol", "Math", "ceil", "numRow", "iterable", "objectInfo", "createIterable", "position", "Array", "pt", "index", "x", "y", "project", "Number", "isFinite", "yIndex", "floor", "xIndex", "key", "count", "points", "lonIdx", "latIdx", "push", "source", "Object", "keys", "length", "i", "idxs", "split", "parseInt", "positionAttribute", "numInstance", "yMin", "Infinity", "yMax", "xMin", "xMax", "GridAggregationLayer", "AggregationLayer", "initializeAggregationLayer", "dimensions", "gl", "context", "setState", "layerData", "gpuGridAggregator", "GPUGridAggregator", "id", "cpuGridAggregator", "pointToDensityGridDataCPU", "updateState", "opts", "updateAggregationState", "aggregationDataDirty", "aggregationWeightsDirty", "gpuAggregation", "state", "getNumInstances", "aggregationDirty", "_updateAggregation", "_updateWeightBins", "_uploadAggregationResults", "finalizeState", "count", "weights", "aggregationBuffer", "delete", "updateShaders", "shaders", "log", "assert", "allocateResources", "numRow", "numCol", "dataBytes", "name", "weight", "Buffer", "byteLength", "accessor", "size", "type", "divisor", "updateResults", "aggregationData", "maxMinData", "maxData", "minData", "gridOffset", "posOffset", "translation", "scaling", "boundingBox", "projectPoints", "props", "viewport", "attributes", "getAttributes", "vertexCount", "result", "run", "cellSize", "xOffset", "yOffset", "moduleSettings", "getModuleSettings", "getValue", "sortedBins", "BinSorter", "data", "aggregatedBins", "minValue", "maxValue", "totalCount", "ELEMENTCOUNT", "aggregationSize", "Float32Array", "fill", "bin", "lonIdx", "latIdx", "i", "value", "counts", "cellIndex", "defaultProps", "ScreenGridCellLayer", "getPosition", "type", "value", "d", "position", "getWeight", "gpuAggregation", "aggregation", "POSITION_ATTRIBUTE_NAME", "DIMENSIONS", "data", "props", "weights", "accessors", "ScreenGridLayer", "GridAggregationLayer", "initializeState", "gl", "context", "isSupported", "setState", "supported", "log", "error", "id", "initializeAggregationLayer", "dimensions", "getCellSize", "cellSizePixels", "count", "size", "operation", "AGGREGATION_OPERATION", "SUM", "needMax", "maxTexture", "getFloatTexture", "projectPoints", "subLayerData", "attributes", "positionAttributeName", "posOffset", "translation", "attributeManager", "getAttributeManager", "add", "accessor", "fp64", "use64bitPositions", "shouldUpdateState", "changeFlags", "state", "somethingChanged", "updateState", "opts", "renderLayers", "numRow", "numCol", "updateTriggers", "aggregationBuffer", "CellLayerClass", "getSubLayerClass", "getSubLayerProps", "instanceCounts", "numInstances", "finalizeState", "maxBuffer", "delete", "getPickingInfo", "info", "index", "gpuGridAggregator", "aggregationResults", "getData", "object", "GPUGridAggregator", "getAggregationData", "pixelIndex", "updateResults", "aggregationData", "maxData", "setData", "setImageData", "updateAggregationState", "cellSize", "cellSizeChanged", "oldProps", "viewportChanged", "warn", "gpuAggregationChanged", "positionsChanged", "isAttributeChanged", "aggregationDataDirty", "isAggregationDirty", "compareAll", "dimension", "aggregationWeightsDirty", "viewport", "width", "height", "Math", "ceil", "allocateResources", "scaling", "gridOffset", "xOffset", "yOffset", "_updateAccessors", "_resetResults", "getValue", "getValueFunc", "nop", "dimensionSteps", "defaultDimensions", "key", "accessor", "pickingInfo", "getBins", "triggers", "value", "prop", "updateTrigger", "weight", "aggregation", "filterData", "getDomain", "lowerPercentile", "upperPercentile", "scaleType", "getScaleFunc", "domain", "range", "onSet", "props", "nullValue", "defaultGetCellSize", "cellSize", "CPUAggregator", "constructor", "opts", "state", "layerData", "dimensions", "changeFlags", "dimensionUpdaters", "_getCellSize", "getCellSize", "_getAggregator", "getAggregator", "_addDimension", "updateState", "aggregationParams", "oldProps", "updateGetValueFuncs", "reprojectNeeded", "needsReProjectPoints", "aggregationDirty", "dataChanged", "getAggregatedData", "dimensionChanges", "getDimensionChanges", "forEach", "f", "setState", "updateObject", "setDimensionState", "normalizeResult", "result", "hexagons", "data", "aggregator", "getSortedBins", "getValue", "getValueChanged", "needUpdateDimensionStep", "wrapGetValueFunc", "getValueFunc", "updateTriggersChanged", "all", "getPosition", "addDimension", "dimension", "getDimensionUpdaters", "sortedBins", "scaleFunc", "updater", "getDimensionSortedBins", "getDimensionValueDomain", "getDimensionScale", "attributeAccessor", "getSubLayerDimensionAttribute", "dimensionStep", "Object", "values", "some", "item", "updaters", "needUpdate", "find", "step", "push", "bind", "length", "getUpdateTriggers", "_updateTriggers", "updateTriggers", "fromProp", "Array", "isArray", "assign", "undefined", "dimensionUpdater", "BinSorter", "_filterData", "valueDomain", "getValueDomainByScale", "dimensionRange", "dimensionDomain", "getScaleFunction", "getScaleFunctionByScaleType", "cell", "bin", "binMap", "index", "counts", "cv", "isValueInDomain", "getSubLayerAccessors", "accessors", "getPickingInfo", "info", "isPicked", "picked", "object", "binInfo", "points", "filteredPoints", "Boolean", "getAccessor", "dimensionKey", "hasOwnProperty", "nop", "defaultProps", "colorDomain", "colorRange", "defaultColorRange", "getColorValue", "type", "value", "getColorWeight", "colorAggregation", "lowerPercentile", "min", "max", "upperPercentile", "colorScaleType", "onSetColorDomain", "elevationDomain", "elevationRange", "getElevationValue", "getElevationWeight", "elevationAggregation", "elevationLowerPercentile", "elevationUpperPercentile", "elevationScale", "elevationScaleType", "onSetElevationDomain", "gridAggregator", "pointToDensityGridDataCPU", "cellSize", "coverage", "getPosition", "x", "position", "extruded", "material", "_filterData", "optional", "CPUGridLayer", "AggregationLayer", "initializeState", "cpuAggregator", "CPUAggregator", "getAggregator", "props", "getCellSize", "state", "aggregatorState", "attributeManager", "getAttributeManager", "add", "positions", "size", "accessor", "updateState", "opts", "setState", "viewport", "context", "attributes", "getAttributes", "numInstances", "getNumInstances", "getPickingInfo", "info", "_onGetSublayerColor", "cell", "getAccessor", "_onGetSublayerElevation", "_getSublayerUpdateTriggers", "getUpdateTriggers", "renderLayers", "transitions", "SubLayerClass", "getSubLayerClass", "GridCellLayer", "updateTriggers", "getFillColor", "bind", "getElevation", "getSubLayerProps", "id", "data", "layerData", "x0", "y0", "x1", "y1", "dx", "dy", "y", "x", "pointToHexbin", "props", "aggregationParams", "data", "radius", "viewport", "attributes", "centerLngLat", "length", "getPointsCenter", "radiusCommon", "getRadiusInCommon", "screenPoints", "iterable", "objectInfo", "createIterable", "positions", "value", "size", "getAccessor", "object", "index", "posIndex", "position", "arrayIsFinite", "Number", "isFinite", "push", "screenCoord", "projectFlat", "source", "log", "warn", "newHexbin", "hexbin", "x", "d", "y", "hexagonBins", "hexagons", "map", "hex", "unprojectFlat", "points", "minX", "Infinity", "minY", "maxX", "maxY", "i", "Math", "min", "max", "every", "center", "unitsPerMeter", "getDistanceScales", "nop", "defaultProps", "colorDomain", "colorRange", "defaultColorRange", "getColorValue", "type", "value", "getColorWeight", "colorAggregation", "lowerPercentile", "min", "max", "upperPercentile", "colorScaleType", "onSetColorDomain", "elevationDomain", "elevationRange", "getElevationValue", "getElevationWeight", "elevationAggregation", "elevationLowerPercentile", "elevationUpperPercentile", "elevationScale", "elevationScaleType", "onSetElevationDomain", "radius", "coverage", "extruded", "hexagonAggregator", "pointToHexbin", "getPosition", "x", "position", "material", "_filterData", "optional", "HexagonLayer", "AggregationLayer", "initializeState", "cpuAggregator", "CPUAggregator", "getAggregator", "props", "getCellSize", "state", "aggregatorState", "vertices", "attributeManager", "getAttributeManager", "add", "positions", "size", "accessor", "updateState", "opts", "changeFlags", "propsOrDataChanged", "viewport", "context", "attributes", "getAttributes", "layerData", "hexagonVertices", "setState", "convertLatLngToMeterOffset", "Array", "isArray", "length", "vertex0", "vertex3", "centroid", "centroidFlat", "projectFlat", "metersPerUnit", "getDistanceScales", "map", "vt", "vtFlat", "log", "error", "getPickingInfo", "info", "_onGetSublayerColor", "cell", "getAccessor", "_onGetSublayerElevation", "_getSublayerUpdateTriggers", "getUpdateTriggers", "renderLayers", "transitions", "SubLayerClass", "getSubLayerClass", "ColumnLayer", "updateTriggers", "geometry", "radiusCommon", "radiusUnits", "angle", "diskResolution", "getFillColor", "bind", "getElevation", "getSubLayerProps", "id", "data", "HALF", "ONE6TH", "OFFSET", "N", "E", "S", "W", "NE", "NW", "SE", "SW", "SW_TRIANGLE", "SE_TRIANGLE", "NE_TRIANGLE", "NW_TRIANGLE", "SW_TRAPEZOID", "SE_TRAPEZOID", "NE_TRAPEZOID", "NW_TRAPEZOID", "S_RECTANGLE", "E_RECTANGLE", "N_RECTANGLE", "W_RECTANGLE", "EW_RECTANGEL", "SN_RECTANGEL", "SQUARE", "SW_PENTAGON", "SE_PENTAGON", "NE_PENTAGON", "NW_PENTAGON", "NW_N_PENTAGON", "NE_E_PENTAGON", "SE_S_PENTAGON", "SW_W_PENTAGON", "NW_W_PENTAGON", "NE_N_PENTAGON", "SE_E_PENTAGON", "SW_S_PENTAGON", "S_HEXAGON", "E_HEXAGON", "N_HEXAGON", "W_HEXAGON", "SW_NE_HEXAGON", "NW_SE_HEXAGON", "NE_HEPTAGON", "SW_HEPTAGON", "NW_HEPTAGON", "SE_HEPTAGON", "OCTAGON", "ISOLINES_CODE_OFFSET_MAP", "ternaryToIndex", "ternary", "parseInt", "ISOBANDS_CODE_OFFSET_MAP", "CONTOUR_TYPE", "ISO_LINES", "ISO_BANDS", "DEFAULT_THRESHOLD_DATA", "zIndex", "zOffset", "getVertexCode", "weight", "threshold", "Array", "isArray", "getCode", "opts", "cellWeights", "x", "y", "width", "height", "thresholdValue", "log", "deprecated", "isLeftBoundary", "isRightBoundary", "isBottomBoundary", "isTopBoundary", "isBoundary", "weights", "codes", "top", "topRight", "right", "current", "code", "Number", "isFinite", "meanCode", "getVertices", "gridOrigin", "cellSize", "type", "thresholdData", "offsets", "ISOBANDS_CODE_OFFSET_MAP", "ISOLINES_CODE_OFFSET_MAP", "vZ", "rX", "rY", "refVertexX", "refVertexY", "polygons", "forEach", "polygonOffsets", "polygon", "xyOffset", "vX", "vY", "push", "lines", "xyOffsets", "offset", "generateContours", "thresholdData", "cellWeights", "gridSize", "gridOrigin", "cellSize", "contourSegments", "contourPolygons", "width", "height", "segmentIndex", "polygonIndex", "data", "contour", "threshold", "x", "y", "code", "meanCode", "getCode", "opts", "type", "CONTOUR_TYPE", "ISO_BANDS", "Array", "isArray", "polygons", "getVertices", "polygon", "vertices", "ISO_LINES", "i", "length", "start", "end", "DEFAULT_COLOR", "DEFAULT_STROKE_WIDTH", "DEFAULT_THRESHOLD", "defaultProps", "cellSize", "type", "min", "max", "value", "getPosition", "x", "position", "getWeight", "gpuAggregation", "aggregation", "contours", "threshold", "optional", "compare", "zOffset", "POSITION_ATTRIBUTE_NAME", "DIMENSIONS", "data", "props", "weights", "accessors", "ContourLayer", "GridAggregationLayer", "initializeState", "initializeAggregationLayer", "dimensions", "setState", "contourData", "projectPoints", "count", "size", "operation", "AGGREGATION_OPERATION", "SUM", "attributeManager", "getAttributeManager", "add", "accessor", "fp64", "use64bitPositions", "updateState", "opts", "contoursChanged", "oldProps", "aggregationDirty", "state", "_updateThresholdData", "getNumInstances", "_generateContours", "renderLayers", "contourSegments", "contourPolygons", "LinesSubLayerClass", "getSubLayerClass", "LineLayer", "BandsSubLayerClass", "SolidPolygonLayer", "lineLayer", "length", "getSubLayerProps", "id", "getSourcePosition", "d", "start", "getTargetPosition", "end", "getColor", "contour", "color", "getWidth", "strokeWidth", "bandsLayer", "getPolygon", "vertices", "getFillColor", "updateAggregationState", "coordinateSystem", "viewport", "context", "cellSizeChanged", "GPUGridAggregator", "isSupported", "gl", "log", "warn", "gpuAggregationChanged", "positionsChanged", "isAttributeChanged", "boundingBox", "getBoundingBox", "getAttributes", "gridOffset", "translation", "width", "height", "numCol", "numRow", "getGridParams", "allocateResources", "posOffset", "slice", "gridOrigin", "aggregationDataDirty", "isAggregationDirty", "dimension", "compareAll", "aggregationWeightsDirty", "_updateAccessors", "_resetResults", "getValue", "getValueFunc", "aggregationData", "thresholdData", "aggregationBuffer", "getData", "cellWeights", "getCellData", "countsData", "generateContours", "gridSize", "xOffset", "yOffset", "Array", "i", "zIndex", "COLOR_DATA_UBO_INDEX", "ELEVATION_DATA_UBO_INDEX", "defaultProps", "colorDomain", "colorRange", "defaultColorRange", "elevationDomain", "elevationRange", "elevationScale", "type", "min", "value", "gridSize", "gridOrigin", "gridOffset", "cellSize", "max", "offset", "coverage", "extruded", "material", "GPUGridCellLayer", "Layer", "getShaders", "vs", "fs", "modules", "project32", "gouraudLighting", "picking", "fp64arithmetic", "initializeState", "gl", "attributeManager", "getAttributeManager", "addInstanced", "colors", "size", "noAlloc", "elevations", "model", "_getModel", "_setupUniformBuffer", "setState", "Model", "id", "props", "geometry", "CubeGeometry", "isInstanced", "draw", "uniforms", "colorMaxMinBuffer", "elevationMaxMinBuffer", "gridOriginLow", "fp64LowPart", "gridOffsetLow", "domainUniforms", "getDomainUniforms", "colorRangeToFlatArray", "bindUniformBuffers", "state", "setUniforms", "unbindUniformBuffers", "bind", "target", "index", "unbind", "colorDomainValid", "elevationDomainValid", "context", "programHandle", "program", "handle", "colorIndex", "getUniformBlockIndex", "elevationIndex", "uniformBlockBinding", "defaultProps", "colorDomain", "colorRange", "defaultColorRange", "getColorWeight", "type", "value", "colorAggregation", "elevationDomain", "elevationRange", "getElevationWeight", "elevationAggregation", "elevationScale", "min", "cellSize", "max", "coverage", "getPosition", "x", "position", "extruded", "material", "DIMENSIONS", "data", "props", "POSITION_ATTRIBUTE_NAME", "GPUGridLayer", "GridAggregationLayer", "initializeState", "gl", "isSupported", "GPUGridAggregator", "log", "error", "initializeAggregationLayer", "dimensions", "setState", "gpuAggregation", "projectPoints", "weights", "color", "needMin", "needMax", "combineMaxMin", "maxMinBuffer", "Buffer", "byteLength", "accessor", "size", "divisor", "elevation", "positionAttributeName", "attributeManager", "getAttributeManager", "add", "fp64", "use64bitPositions", "updateState", "opts", "state", "aggregationDirty", "gridHash", "getHashKeyForIndex", "index", "numRow", "numCol", "boundingBox", "gridOffset", "gridSize", "gridOrigin", "xMin", "yMin", "xOffset", "yOffset", "yIndex", "Math", "floor", "xIndex", "latIdx", "lonIdx", "getPositionForIndex", "yPos", "xPos", "getPickingInfo", "info", "mode", "object", "gpuGridAggregator", "colorInfo", "getAggregationData", "pixelIndex", "getData", "elevationInfo", "colorValue", "cellWeight", "elevationValue", "count", "cellCount", "totalCount", "translation", "viewport", "context", "attributes", "getAttributes", "cpuAggregation", "pointToDensityGridDataCPU", "key", "cpuAggregationData", "Object", "assign", "picked", "Boolean", "renderLayers", "cellSizeMeters", "colorRangeToFlatArray", "SubLayerClass", "getSubLayerClass", "GPUGridCellLayer", "getSubLayerProps", "id", "colors", "aggregationBuffer", "elevations", "colorMaxMinBuffer", "elevationMaxMinBuffer", "numInstances", "finalizeState", "forEach", "weight", "delete", "updateAggregationState", "oldProps", "coordinateSystem", "cellSizeChanged", "positionsChanged", "isAttributeChanged", "attributesChanged", "getBoundingBox", "getNumInstances", "width", "height", "getGridParams", "allocateResources", "aggregationDataDirty", "isAggregationDirty", "dimension", "compareAll", "_updateAccessors", "operation", "AGGREGATION_OPERATION", "defaultProps", "GPUGridLayer", "CPUGridLayer", "gpuAggregation", "GridLayer", "CompositeLayer", "initializeState", "state", "useGPUAggregation", "updateState", "props", "setState", "canUseGPUAggregation", "renderLayers", "data", "updateTriggers", "id", "LayerType", "getSubLayerClass", "getSubLayerProps", "lowerPercentile", "upperPercentile", "getColorValue", "getElevationValue", "colorScaleType", "GPUGridAggregator", "isSupported", "context", "gl", "getBounds", "points", "x", "map", "p", "y", "xMin", "Math", "min", "apply", "xMax", "max", "yMin", "yMax", "boundsContain", "currentBounds", "targetBounds", "scratchArray", "Float32Array", "packVertices", "dimensions", "index", "point", "i", "scaleToAspectRatio", "boundingBox", "width", "height", "currentWidth", "currentHeight", "newWidth", "newHeight", "xCenter", "yCenter", "getTextureCoordinates", "bounds", "getTextureParams", "gl", "floatTargetSupport", "format", "isWebGL2", "type", "TriangleLayer", "Layer", "getShaders", "vs", "fs", "modules", "project32", "initializeState", "gl", "attributeManager", "getAttributeManager", "add", "positions", "size", "noAlloc", "texCoords", "setState", "model", "_getModel", "vertexCount", "props", "Model", "id", "geometry", "Geometry", "drawMode", "draw", "uniforms", "state", "texture", "maxTexture", "colorTexture", "intensity", "threshold", "aggregationMode", "colorDomain", "setUniforms", "RESOLUTION", "TEXTURE_OPTIONS", "mipmaps", "parameters", "dataFormat", "DEFAULT_COLOR_DOMAIN", "AGGREGATION_MODE", "SUM", "MEAN", "defaultProps", "getPosition", "type", "value", "x", "position", "getWeight", "intensity", "min", "radiusPixels", "max", "colorRange", "defaultColorRange", "threshold", "colorDomain", "optional", "aggregation", "weightsTextureSize", "debounceTimeout", "REQUIRED_FEATURES", "FEATURES", "BLEND_EQUATION_MINMAX", "TEXTURE_FLOAT", "FLOAT_TARGET_FEATURES", "COLOR_ATTACHMENT_RGBA32F", "FLOAT_BLEND", "DIMENSIONS", "data", "props", "HeatmapLayer", "AggregationLayer", "initializeState", "gl", "context", "hasFeatures", "setState", "supported", "log", "error", "id", "initializeAggregationLayer", "_setupTextureParams", "_setupAttributes", "_setupResources", "shouldUpdateState", "changeFlags", "somethingChanged", "updateState", "opts", "state", "_updateHeatmapState", "oldProps", "_getChangeFlags", "dataChanged", "viewportChanged", "boundsChanged", "_updateBounds", "_updateTextureRenderingBounds", "clearTimeout", "updateTimer", "isWeightMapDirty", "viewportZoomChanged", "_debouncedUpdateWeightmap", "_updateColorTexture", "_updateWeightmap", "zoom", "viewport", "renderLayers", "weightsTexture", "triPositionBuffer", "triTexCoordBuffer", "maxWeightsTexture", "colorTexture", "updateTriggers", "TriangleLayerClass", "getSubLayerClass", "TriangleLayer", "getSubLayerProps", "coordinateSystem", "COORDINATE_SYSTEM", "DEFAULT", "attributes", "positions", "texCoords", "vertexCount", "maxTexture", "aggregationMode", "texture", "finalizeState", "weightsTransform", "maxWeightTransform", "delete", "_getAttributeManager", "AttributeManager", "stats", "dimensions", "isAttributeChanged", "isAggregationDirty", "compareAll", "dimension", "_createTextures", "textureSize", "format", "Texture2D", "width", "height", "attributeManager", "getAttributeManager", "add", "size", "accessor", "weights", "positionAttributeName", "Math", "getParameters", "floatTargetSupport", "getTextureParams", "weightsScale", "warn", "getShaders", "vs", "vsMax", "_fs", "fsMax", "weightsVs", "weightsFs", "_createWeightsTransform", "shaders", "Transform", "elementCount", "_targetTexture", "_targetTextureVarying", "weightsTransformShaders", "maxWeightsTransformShaders", "_sourceTextures", "inTexture", "Buffer", "byteLength", "updateShaders", "shaderOptions", "_updateMaxWeightValue", "run", "blend", "depthTest", "blendFunc", "blendEquation", "forceUpdate", "viewportCorners", "unproject", "map", "p", "fround", "visibleWorldBounds", "getBounds", "newState", "worldBounds", "boundsContain", "scaledCommonBounds", "_worldToCommonBounds", "_commonToWorldBounds", "LNGLAT", "normalizedCommonBounds", "subData", "packVertices", "textureBounds", "getTextureCoordinates", "projectPosition", "colors", "colorRangeToFlatArray", "Uint8Array", "setImageData", "length", "commonBounds", "useLayerCoordinateSystem", "metersPerPixel", "distanceScales", "metersPerUnit", "uniforms", "textureWidth", "update", "getNumInstances", "withParameters", "clearColor", "clearRenderTarget", "getAttributes", "moduleSettings", "getModuleSettings", "setParameters", "fromTimer", "setTimeout", "bind", "minLong", "minLat", "maxLong", "maxLat", "offsetMode", "LNGLAT_OFFSETS", "METER_OFFSETS", "offsetOriginCommon", "coordinateOrigin", "scale", "bottomLeftCommon", "topRightCommon", "scaleToAspectRatio", "xMin", "yMin", "xMax", "yMax", "bottomLeftWorld", "unprojectPosition", "topRightWorld", "slice", "concat"]
}
